<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python语法 | Liu's  Blog</title><meta name="author" content="LHF"><meta name="copyright" content="LHF"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="python常见语法记录">
<meta property="og:type" content="article">
<meta property="og:title" content="Python语法">
<meta property="og:url" content="https://liuhengfeng.xyz/posts/3152c1c3.html">
<meta property="og:site_name" content="Liu&#39;s  Blog">
<meta property="og:description" content="python常见语法记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://statics.liuhengfeng.xyz/Hexo/PixPin_2025-03-19_13-48-56.png">
<meta property="article:published_time" content="2025-03-20T05:31:08.000Z">
<meta property="article:modified_time" content="2025-03-20T05:31:08.000Z">
<meta property="article:author" content="LHF">
<meta property="article:tag" content="技能学习">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://statics.liuhengfeng.xyz/Hexo/PixPin_2025-03-19_13-48-56.png"><link rel="shortcut icon" href="https://statics.liuhengfeng.xyz/Hexo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240907191402.jpg"><link rel="canonical" href="https://liuhengfeng.xyz/posts/3152c1c3.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":290},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python语法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-20 13:31:08'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="https://statics.liuhengfeng.xyz/css/custom.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://statics.liuhengfeng.xyz/css/universe.css"><span id="fps"></span><link rel="stylesheet" href="https://statics.liuhengfeng.xyz/css/hexo_electric_clock.css"><link rel="stylesheet" href="/css/bottom_runtime.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/lib/theme-chalk/index.css"><link rel="stylesheet" href="/css/calendar.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://statics.liuhengfeng.xyz/css/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://statics.liuhengfeng.xyz/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/u%3D1968668429%2C2104382916%26fm%3D253%26fmt%3Dauto%26app%3D138%26f%3DJPEG.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://statics.liuhengfeng.xyz/Hexo/PixPin_2025-03-19_13-48-56.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Liu's  Blog"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/2876f803-ae9a-49ac-bcd9-9d623c5beb03.jpg"/><span class="site-name">Liu's  Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python语法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-20T05:31:08.000Z" title="发表于 2025-03-20 13:31:08">2025-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-20T05:31:08.000Z" title="更新于 2025-03-20 13:31:08">2025-03-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python语法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>Python官方文档网站</p>
</blockquote>
<p>多读读能更加了解Python的各种语法与相关特性，有中文版的，碰到不懂的语法问题也可以上去查找一下。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.13/">Python官方文档</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/image-20250724010956729.png" alt="Python文档"></p>
<h1 id="导包-import"><a href="#导包-import" class="headerlink" title="导包(import)"></a>导包(import)</h1><h2 id="包与模块"><a href="#包与模块" class="headerlink" title="包与模块"></a>包与模块</h2><p><code>import</code> 将一个模块（module）或包（package）中的代码引入到当前文件中，从而复用其他模块&#x2F;包的已实现功能。导入同一个目录下的模块和不同的目录的模块是完全不同的。</p>
<blockquote>
<p>什么是模块（module），什么是包（package）</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/image-20250724172532107.png" alt="包与模块"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/image-20250724172706860.png" alt="包内部的模块"></p>
<p><strong>模块与包的关系，可以类比为文件和目录，模块就是文件，目录就是包。</strong></p>
<p>一个 <code>module</code> 里面包含变量、函数和类，它们属于该 <code>module</code> 定义的命名空间的一部分，两个不同的模块可以有同名的变量、函数和类。<code>package</code> 里面一般是<code>module</code>，也可以有子包（sub-package）。一个模块定义一个命名空间，以便变量、函数和类可以在两个不同的模块中具有相同的名称(很少)，<strong>通过点号<code>.</code>访问主包(package)中的模块和子包，包目录下通常会有一个特殊的 <code>__init__.py</code> 文件，表名这个目录是一个Python包。</strong></p>
<p><code>setup.py</code> 存在于 <code>package</code> 所在的主目录中，包含配置信息，如所需的依赖项、脚本和子包。还可以指定有关 <code>package</code> 的元数据，例如 <code>package</code> 的名称、作者、描述等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/image-20250724170347388.png" alt="package结构示例"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 包目录结构示例：</span><br><span class="line"># my_package/</span><br><span class="line"># ├── __init__.py</span><br><span class="line"># ├── utils/</span><br><span class="line"># │   ├── __init__.py</span><br><span class="line"># │   └── helper.py</span><br><span class="line"># └── data/</span><br><span class="line">#     ├── __init__.py</span><br><span class="line">#     └── processor.py</span><br><span class="line"></span><br><span class="line"># 在其他文件中，这样导入</span><br><span class="line">from my_package.utils import helper</span><br><span class="line">helper.some_function()</span><br><span class="line"></span><br><span class="line">from my_package.data import processor</span><br><span class="line">processor.do_something()</span><br></pre></td></tr></table></figure>

<h2 id="Python导包相关"><a href="#Python导包相关" class="headerlink" title="Python导包相关"></a>Python导包相关</h2><h3 id="init-py的作用"><a href="#init-py的作用" class="headerlink" title="__init__.py的作用"></a><code>__init__.py</code>的作用</h3><ul>
<li><p><strong>标识为包（Package）</strong>：<code>__init__.py</code> 文件是一个特殊的文件，它用来标志一个目录属于 <strong>Python 包</strong>，让 Python 解释器知道这个目录下的模块（<code>.py</code> 文件）可以被导入（<code>import</code>）。如果没有<code>__init__.py</code>，该目录只会被视为一个普通的文件夹，将无法从这个目录中导入任何模块。<code>__init__.py</code>文件可以是空的，但它的存在至关重要，起到标识作用。</p>
</li>
<li><p><strong>初始化代码</strong>：**<code>__init__.py</code> 文件中的代码在包被导入时会自动执行**。可以在包层面做一些初始化工作，比如设置包级别的变量、导入子模块或者执行一些配置任务。</p>
</li>
<li><p><strong>控制包的导入行为</strong>：可以在 <code>__init__.py</code> 中明确地暴露包中的某些模块或对象，从而简化导入的语法。例如，可以在 <code>__init__.py</code> 中写 <code>from . import submodule</code>，这样当用户执行 <code>import mypackage</code> 时，<code>submodule</code> 就可以通过 <code>mypackage.submodule</code> 来访问，而不需要 <code>import mypackage.submodule</code>。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 假设目录结构：</span><br><span class="line">my_project/</span><br><span class="line">|-- my_package/</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- module_a.py</span><br><span class="line">|   |-- module_b.py</span><br><span class="line">|-- main.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果 my_package 目录下没有 __init__.py 文件，那么在 main.py 中尝试导入 my_package 将会失败，Python 解释器不知道 	 # my_package 是一个包，所以无法找到它里面的模块</span><br><span class="line"># main.py</span><br><span class="line">import my_package.module_a</span><br><span class="line"></span><br><span class="line"># 运行 main.py</span><br><span class="line"># 将会报错：ModuleNotFoundError: No module named &#x27;my_package&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 利用__init__.py简化导入</span><br><span class="line"></span><br><span class="line">my_project/</span><br><span class="line">|-- my_package/</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- module_a.py		# 假设module_a.py包含def say_hello()</span><br><span class="line">|   |-- module_b.py		# 假设module_b.py包含def say_goodbye()</span><br><span class="line">|-- main.py</span><br><span class="line"></span><br><span class="line"># my_package/__init__.py文件写入如下内容</span><br><span class="line">from .module_a import say_hello</span><br><span class="line">from .module_b import say_goodbye</span><br><span class="line"></span><br><span class="line"># 也可以用来控制 `from my_package import *` 的行为</span><br><span class="line">__all__ = [&quot;say_hello&quot;, &quot;say_goodbye&quot;]</span><br><span class="line"></span><br><span class="line"># 这样修改后，main.py 中的导入方式就可以变得更简洁</span><br><span class="line">from my_package import say_hello, say_goodbye</span><br><span class="line"></span><br><span class="line">print(say_hello())</span><br><span class="line">print(say_goodbye())</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/image-20250807144254618.png" alt="文件夹与Python包"></p>
<h3 id="导包规则"><a href="#导包规则" class="headerlink" title="导包规则"></a>导包规则</h3><p><code>import</code> 的核心作用是<strong>将一个模块或包加载到内存中</strong>，并提供对其中内容的访问权限。当执行 <code>import</code> 语句时，Python 解释器会做以下几件事：</p>
<ul>
<li><strong>查找模块</strong>：python 所有的包都会从 <code>sys.path</code> 中获取，<code>sys.path</code>返回的是一个路径列表，代表<strong>Python导包时搜素的路径</strong>。这个列表通常包括当前工作目录（（运行.py脚本所在的目录）、Python 标准库的安装目录以及已安装的第三方库目录。<ul>
<li><strong>当前目录（Current Directory）</strong>：首先，Python 会在执行脚本的目录及其子目录中查找。例如在 <code>D:\Python Project\Pythonic\demo1\RAG</code> 目录下运行 <code>streamlit run txt_search.py</code>，当前目录是 <code>RAG</code>，Python 不会自动向上查找 <code>demo1</code> 或 <code>Pythonic</code> 下的其他模块。</li>
<li><strong><code>PYTHONPATH</code> 环境变量</strong>：如果设置了 <code>PYTHONPATH</code> 环境变量，Python 会将其中指定的目录添加到 <code>sys.path</code> 中。可以用它来添加那些不在默认路径中的自定义模块目录。</li>
<li><strong>标准库目录</strong>：Python 还会在安装目录下的标准库<code>(E:\Python3.9\Lib)</code>中搜索。这里包含了像 <code>os</code>、<code>sys</code>、<code>json</code> 等内置模块。</li>
<li><strong>第三方库目录（<code>site-packages</code>）</strong>：最后，它会在 <code>site-packages</code> 目录<code>(E:\Python3.9\Lib\site-packages)</code>中搜索。这里是 pip 安装的第三方库（如 <code>pandas</code>、<code>numpy</code>）的存放位置。</li>
<li>如果 Python 在上述任何一个目录中找到了对应的模块文件（例如 <code>my_module.py</code>），它就会停止搜索并加载该模块。<strong>如果遍历了<code>sys.path</code>的所有路径仍然找不到，就会抛出 <code>ModuleNotFoundError</code>。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sys.path示例</span><br><span class="line">[&#x27;D:\\Python Project\\Pythonic\\Pythonic\\demo1\\LangGraph&#x27;, &#x27;D:\\Python Project\\Pythonic&#x27;, &#x27;E:\\PyCharm 2024.1.1\\plugins\\python\\helpers\\pycharm_display&#x27;, &#x27;E:\\anaconda3\\envs\\Juke_AI_Project\\python39.zip&#x27;, &#x27;E:\\anaconda3\\envs\\Juke_AI_Project\\DLLs&#x27;, &#x27;E:\\anaconda3\\envs\\Juke_AI_Project\\lib&#x27;, &#x27;E:\\anaconda3\\envs\\Juke_AI_Project&#x27;, &#x27;E:\\anaconda3\\envs\\Juke_AI_Project\\lib\\site-packages&#x27;, &#x27;E:\\PyCharm 2024.1.1\\plugins\\python\\helpers\\pycharm_matplotlib_backend&#x27;]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>执行模块代码</strong>：如果找到了模块文件（<code>.py</code>），解释器会从头到尾执行一遍模块中的所有代码。在这个过程中，模块中的所有变量、函数和类都会被定义并存储在一个字典中，<strong>这个字典就是模块的命名空间</strong>。</p>
</li>
<li><p><strong>缓存模块</strong>：模块只会被导入一次。首次导入后，它会被缓存到 <code>sys.modules</code> 字典中。后续的 <code>import</code> 语句，如果模块名相同，将直接从缓存中获取，而不会重新执行模块代码。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前的模块搜索路径</span><br><span class="line">import sys</span><br><span class="line">import pprint</span><br><span class="line"></span><br><span class="line">pprint.pprint(sys.path)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>import</code>导包优良习惯</p>
</blockquote>
<ul>
<li><p>**尽量不使用 <code>from module import *</code>**：避免命名空间污染，尤其是在大型项目中。因为它会使当前命名空间变得混乱，无法知道一个函数或变量是来自哪个模块，极易引发命名冲突，降低代码的可读性。</p>
</li>
<li><p><strong>将 <code>import</code> 语句放在文件顶部</strong>：这是 PEP 8（Python 代码风格指南）的规定，可以提高代码的可读性。</p>
</li>
<li><p>**按标准库、第三方库和自定义模块的顺序分组 <code>import</code>**：这样能让代码结构更清晰。</p>
</li>
<li><p><strong>使用别名来简化长模块名或避免冲突</strong>：例如，<code>import numpy as np</code>。</p>
</li>
<li><p><strong>使用相对导入</strong>：在包内部的模块之间导入时，可以使用 <code>.</code> 和 <code>..</code> 来进行相对导入，例如 <code>from . import module</code> 或 <code>from .. import package</code>。这可以避免硬编码包名，使代码更具可移植性。</p>
</li>
</ul>
<h3 id="追加新的导包路径（稳定解决ModuleNotFoundError）"><a href="#追加新的导包路径（稳定解决ModuleNotFoundError）" class="headerlink" title="追加新的导包路径（稳定解决ModuleNotFoundError）"></a>追加新的导包路径（稳定解决<code>ModuleNotFoundError</code>）</h3><p>出现<code>ModuleNotFoundError</code>时，可以在程序运行时动态追加新的导包路径；</p>
<p>最稳定的方法：<strong>手动修改 <code>sys.path</code>，确保项目根目录始终在搜索路径中。</strong></p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 明确项目结构的方法</span><br><span class="line">sys.path.append(&#x27;D:/Python Project/Pythonic&#x27;)	# 追加到末尾</span><br><span class="line">sys.path.insert(0, &#x27;D:/Python Project/Pythonic&#x27;)   # 追加到开头位置，可以确保先搜索这个路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 通用方法</span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def add_project_root_to_path(root_dir_name, script_file=__file__):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    动态地将指定名称的项目根目录添加到 sys.path。</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        root_dir_name (str): 项目根目录的名称。</span><br><span class="line">        script_file (str): 调用此函数的脚本的路径。默认为 __file__。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    current_script_path = os.path.abspath(script_file)</span><br><span class="line">    current_dir = os.path.dirname(current_script_path)</span><br><span class="line"></span><br><span class="line">    # 循环向上查找，直到找到项目根目录或到达文件系统根目录</span><br><span class="line">    while os.path.basename(current_dir) != root_dir_name and current_dir != os.path.dirname(current_dir):</span><br><span class="line">        current_dir = os.path.dirname(current_dir)</span><br><span class="line"></span><br><span class="line">    # 检查是否找到了项目根目录</span><br><span class="line">    if os.path.basename(current_dir) == root_dir_name:</span><br><span class="line">        if current_dir not in sys.path:</span><br><span class="line">            sys.path.insert(0, current_dir)</span><br><span class="line">            # print(f&quot;项目根目录 &#x27;&#123;current_dir&#125;&#x27; 已成功添加到 sys.path。&quot;)</span><br><span class="line">    # else:</span><br><span class="line">    #     print(f&quot;警告: 未找到项目根目录 &#x27;&#123;root_dir_name&#125;&#x27;。&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 假设项目根目录是 &#x27;Pythonic&#x27;</span><br><span class="line"># add_project_root_to_path(&#x27;Pythonic&#x27;)</span><br><span class="line"></span><br><span class="line"># 然后就可以安全地使用绝对导入了</span><br><span class="line"># from demo1.model.LLM import model</span><br></pre></td></tr></table></figure>

<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="字典的键"><a href="#字典的键" class="headerlink" title="字典的键"></a>字典的键</h2><p>在 Python 中，字典的键必须是不可变类型，因为键需要是可哈希的（hashable）。可哈希的对象在程序运行期间保持不变的哈希值，用于字典的快速查找。以下是可以作为字典键的类型：</p>
<ul>
<li>整数（int）</li>
<li>浮点数（float）</li>
<li>字符串（str）——最常用</li>
<li>布尔值（bool）：如 True, False</li>
</ul>
<ul>
<li><p><strong>元组（tuple）</strong>：如 (1, “chat1”)，<strong>前提是元组内的元素也必须是不可变的（不能包含列表等可变类型）。</strong></p>
</li>
<li><p><strong>冻结集合（frozenset）</strong>：如 frozenset([1, 2, 3])，不可变的集合类型。</p>
</li>
<li><p><strong>自定义对象</strong>：如果自定义类实现了 <strong>hash</strong>() 方法且是不可变的，可以作为键。</p>
</li>
</ul>
<p>字典的键 不能是可变类型，因为可变对象的哈希值可能在运行时改变，导致字典无法正确查找键。以下是不能作为字典键的类型：</p>
<ul>
<li><p><strong>列表（list）</strong>：如 [1, 2, 3]，因为列表可以修改（如添加、删除元素）。</p>
</li>
<li><p><strong>集合（set）</strong>：如 {1, 2, 3}，因为集合是可变的。</p>
</li>
<li><p><strong>字典（dict）</strong>：如 {“a”: 1}，因为字典本身是可变的。</p>
</li>
<li><p><strong>可变自定义对象</strong>：如果对象的内容可以改变（如修改属性），则不能作为键。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 可以作为键</span><br><span class="line">d = &#123;</span><br><span class="line">    1: &quot;integer&quot;,</span><br><span class="line">    &quot;key&quot;: &quot;string&quot;,</span><br><span class="line">    (101, &quot;chat1&quot;): &quot;tuple&quot;,</span><br><span class="line">    True: &quot;boolean&quot;,</span><br><span class="line">    frozenset([1, 2]): &quot;frozenset&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(d[1])  # 输出: integer</span><br><span class="line">print(d[(101, &quot;chat1&quot;)])  # 输出: tuple</span><br><span class="line"></span><br><span class="line"># 不能作为键</span><br><span class="line">try:</span><br><span class="line">    d[&#123;1, 2&#125;] = &quot;set&quot;  # TypeError: unhashable type: &#x27;set&#x27;</span><br><span class="line">except TypeError as e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    d[[1, 2]] = &quot;list&quot;  # TypeError: unhashable type: &#x27;list&#x27;</span><br><span class="line">except TypeError as e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>

<h1 id="位置参数与关键字参数"><a href="#位置参数与关键字参数" class="headerlink" title="位置参数与关键字参数"></a>位置参数与关键字参数</h1><p><strong>位置参数（Positional Argument）</strong> 和 <strong>关键字参数（Keyword Argument）</strong> 是两种常见的函数参数传递方式。</p>
<h2 id="1-位置参数（Positional-Argument）"><a href="#1-位置参数（Positional-Argument）" class="headerlink" title="1. 位置参数（Positional Argument）"></a>1. <strong>位置参数（Positional Argument）</strong></h2><ul>
<li>位置参数是按照函数<strong>定义参数的顺序</strong>传递的</li>
<li>传递参数时，<strong>顺序必须匹配</strong>函数的参数顺序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 示例</span><br><span class="line">def greet(name, age):</span><br><span class="line">    print(f&quot;Hello, my name is &#123;name&#125; and I am &#123;age&#125; years old.&quot;)</span><br><span class="line"></span><br><span class="line">greet(&quot;Alice&quot;, 25)  # 位置参数，按顺序匹配 name=&quot;Alice&quot;, age=25</span><br><span class="line"></span><br><span class="line"># 如果参数顺序错误，可能导致错误或意外的结果。</span><br><span class="line">greet(25, &quot;Alice&quot;)  # 结果会不正确</span><br><span class="line">Hello, my name is 25 and I am Alice years old.</span><br></pre></td></tr></table></figure>

<h2 id="2-关键字参数（Keyword-Argument）"><a href="#2-关键字参数（Keyword-Argument）" class="headerlink" title="2. 关键字参数（Keyword Argument）"></a>2. <strong>关键字参数（Keyword Argument）</strong></h2><ul>
<li>关键字参数<strong>通过参数名</strong>来传递的值，而不依赖位置（顺序）</li>
<li>这样可以<strong>不考虑参数的书写顺序</strong>，只要参数名称匹配得上即可</li>
<li>允许改变参数顺序，不会影响函数的执行结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 示例</span><br><span class="line">greet(age=25, name=&quot;Alice&quot;)  # 顺序无关紧要</span><br><span class="line">Hello, my name is Alice and I am 25 years old.</span><br></pre></td></tr></table></figure>

<h2 id="3-混合使用位置参数和关键字参数"><a href="#3-混合使用位置参数和关键字参数" class="headerlink" title="3. 混合使用位置参数和关键字参数"></a>3. <strong>混合使用位置参数和关键字参数</strong></h2><ul>
<li><strong>位置参数必须写在前面，关键字参数写在后面</strong>，否则会报错。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 正确</span><br><span class="line">greet(&quot;Alice&quot;, age=25)  # 位置参数 + 关键字参数</span><br><span class="line"># 错误</span><br><span class="line">greet(name=&quot;Alice&quot;, 25)  # 关键字参数后面不能有位置参数</span><br><span class="line">SyntaxError: positional argument follows keyword argument</span><br></pre></td></tr></table></figure>

<h2 id="4-默认参数（Default-Argument）"><a href="#4-默认参数（Default-Argument）" class="headerlink" title="4. 默认参数（Default Argument）"></a>4. <strong>默认参数（Default Argument）</strong></h2><ul>
<li>为关键字参数设置默认值，使其成为<strong>可选参数</strong>，用户未给默认参数赋值时使用默认值，如果用户在调用函数的同时给默认参数赋予了值，则采用用户赋予的新值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def greet(name, age=18):  # age 设定默认值 18</span><br><span class="line">    print(f&quot;Hello, my name is &#123;name&#125; and I am &#123;age&#125; years old.&quot;)</span><br><span class="line"></span><br><span class="line">greet(&quot;Bob&quot;)       # 没提供 age，默认值生效</span><br><span class="line">greet(&quot;Alice&quot;, 25) # 提供了 age，使用 25</span><br></pre></td></tr></table></figure>

<h2 id="5-函数参数列表中的-符号含义"><a href="#5-函数参数列表中的-符号含义" class="headerlink" title="5.函数参数列表中的*符号含义"></a>5.函数参数列表中的<code>*</code>符号含义</h2><p>在 Python 函数的<strong>参数列表</strong>中，<code>*</code>（单独的星号）是一个特殊的语法，它表示<strong>强制关键字参数</strong>，意思是<strong>它后面的所有参数都必须以关键字参数的形式传递，而不能以位置参数的形式传递。</strong>在 <code>*</code> 之前的参数，既可以作为位置参数传递，也可以作为关键字参数传递，在 <code>*</code> 之后的参数，意味着它们<strong>只能作为关键字参数传递，包括<code>**kwargs</code></strong></p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 传入示例</span><br><span class="line">PromptTemplate.from_template(&quot;Hello &#123;name&#125;&quot;, template_format=&quot;f-string&quot;, default_value=&quot;world&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">   def from_template(</span><br><span class="line">       cls,</span><br><span class="line">       template: str,</span><br><span class="line">       *,  # &lt;------这里的`*`就代表后面的template_format和 partial_variables都必须是关键字参数</span><br><span class="line">       template_format: PromptTemplateFormat = &quot;f-string&quot;,</span><br><span class="line">       partial_variables: Optional[dict[str, Any]] = None,</span><br><span class="line">       **kwargs: Any,</span><br><span class="line">   ) -&gt; PromptTemplate:</span><br><span class="line">       input_variables = get_template_variables(template, template_format)</span><br><span class="line">       partial_variables_ = partial_variables or &#123;&#125;</span><br><span class="line"></span><br><span class="line">       if partial_variables_:</span><br><span class="line">           input_variables = [</span><br><span class="line">               var for var in input_variables if var not in partial_variables_</span><br><span class="line">           ]</span><br><span class="line"></span><br><span class="line">       return cls(</span><br><span class="line">           input_variables=input_variables,</span><br><span class="line">           template=template,</span><br><span class="line">           template_format=template_format,</span><br><span class="line">           partial_variables=partial_variables_,</span><br><span class="line">           **kwargs,</span><br><span class="line">       )</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/image-20250319141359479.png" alt="位置参数与关键字参数"></p>
<h1 id="参数收集器-参数解包器-args、kwargs）"><a href="#参数收集器-参数解包器-args、kwargs）" class="headerlink" title="参数收集器&#x2F;参数解包器(args、kwargs）"></a>参数收集器&#x2F;参数解包器(args、kwargs）</h1><p>在 Python 中，<code>*args</code> 和 <code>**kwargs</code> 被称为参数收集器或参数解包器，用于<strong>定义函数时</strong>接收可变数量的参数。主要用于函数定义，可以将<strong>不定数量</strong>的参数传递给一个函数，提高函数的灵活性，使其能够处理不同数量的输入参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def example_function(a, b, *args, c=10, **kwargs):</span><br><span class="line">    print(f&quot;a = &#123;a&#125;, b = &#123;b&#125;&quot;)</span><br><span class="line">    print(f&quot;args = &#123;args&#125;&quot;)  # 额外的位置参数</span><br><span class="line">    print(f&quot;c = &#123;c&#125;&quot;)  # 关键字参数，带默认值</span><br><span class="line">    print(f&quot;kwargs = &#123;kwargs&#125;&quot;)  # 额外的关键字参数</span><br><span class="line"></span><br><span class="line">example_function(1, 2, 3, 4, c=20, x=30, y=40)</span><br><span class="line"></span><br><span class="line">a = 1, b = 2</span><br><span class="line">args = (3, 4)</span><br><span class="line">c = 20</span><br><span class="line">kwargs = &#123;&#x27;x&#x27;: 30, &#x27;y&#x27;: 40&#125;</span><br></pre></td></tr></table></figure>

<h2 id="args"><a href="#args" class="headerlink" title="*args"></a>*args</h2><p><code>*</code> 表示解包，<code>args</code> 是一个约定俗成的名称（<code>args</code> 是 <code>arguments</code> 的缩写，名称可以自定义如 <code>*numbers</code>），但通常用 args。<strong>允许函数接受任意数量的位置参数，并将参数打包成一个元组（tuple）传递给函数内部</strong>。在函数内部，可以使用 <code>args</code> 来遍历访问获取这些参数。这意味着可以传递任意数量的<code>位置参数</code>给函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 示例</span><br><span class="line">def test_var_args(f_arg, *args):</span><br><span class="line">    print(&quot;first normal arg:&quot;,f_arg)</span><br><span class="line">    for arg in args:</span><br><span class="line">        print(&quot;another arg through *args:&quot;,arg)</span><br><span class="line">test_var_args(&#x27;yasoob&#x27;,&#x27;python&#x27;,&#x27;eggs&#x27;,&#x27;test&#x27;)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">first normal arg: yasoob</span><br><span class="line">another arg through *args: python</span><br><span class="line">another arg through *args: eggs</span><br><span class="line">another arg through *args: test</span><br><span class="line"></span><br><span class="line"># 示例2  定义一个打印的函数，传入任意参数即可</span><br><span class="line">def print_func(*args):</span><br><span class="line">    print(type(args))</span><br><span class="line">    print(args)</span><br><span class="line">print_func(1,2,&#x27;python&#x27;,[])</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line">(1, 2, &#x27;python&#x27;, [])</span><br><span class="line"></span><br><span class="line"># 示例3 在打印函数的参数处，新增 x 和 y 变量</span><br><span class="line">def print_func(x,y,*args):</span><br><span class="line">    print(type(x))</span><br><span class="line">    print(x)</span><br><span class="line">    print(y)</span><br><span class="line">    print(type(args))</span><br><span class="line">    print(args)</span><br><span class="line">print_func(1,2,&#x27;python&#x27;,[])</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line">(&#x27;python&#x27;, [])</span><br></pre></td></tr></table></figure>

<h2 id="kwargs"><a href="#kwargs" class="headerlink" title="**kwargs"></a>**kwargs</h2><p><code>**kwargs</code> 是 <strong>keyword arguments</strong> 的缩写，表示关键字参数。允许将不定长度的键值对 <code>key-value</code> ，作为参数传递给一个函数。如果想要在函数里处理带名字的参数，应该使用<code>**kwargs</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 示例1</span><br><span class="line">def print_func(**kwargs):</span><br><span class="line">    print(type(kwargs))</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">print_func(a=1, b=2, c=&#x27;呵呵&#x27;, d=[])</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: &#x27;呵呵&#x27;, &#x27;d&#x27;: []&#125;</span><br><span class="line"></span><br><span class="line"># 示例2</span><br><span class="line">def greet_me(**kwargs):</span><br><span class="line">    for key, value in kwargs.items():</span><br><span class="line">        print(&quot;&#123;0&#125; == &#123;1&#125;&quot;.format(key, value))</span><br><span class="line">greet_me(name=&quot;yasoob&quot;)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">name == yasoob</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><code>arg,*args,**kwargs</code> ,三者是可以组合使用的，但是组合使用需要遵循一定的语法规则，即顺序为王。使用时要求 <code>*args</code> 参数必须在<code>** kwargs</code> 前面 【<strong>因为位置参数需要在关键字参数的前面</strong>。】</p>
<ul>
<li><code>*args</code> 用于接收任意数量的位置参数，返回一个元组。</li>
<li><code>**kwargs</code> 用于接收任意数量的关键字参数，返回一个字典。</li>
<li>在函数定义中可以同时使用 <code>*args</code> 和 <code>**kwargs</code> 来提高灵活性。</li>
<li><code>*</code> 和 <code>**</code> 还可以在函数调用时解包序列（列表、字典等）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def print_func(x, *args, **kwargs):</span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">print_func(1, 2, 3, 4, y=1, a=2, b=3, c=4)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">1</span><br><span class="line">(2, 3, 4)</span><br><span class="line">&#123;&#x27;y&#x27;: 1, &#x27;a&#x27;: 2, &#x27;b&#x27;: 3, &#x27;c&#x27;: 4&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Python装饰器"><a href="#Python装饰器" class="headerlink" title="Python装饰器"></a>Python装饰器</h1><p>Python 语言中，<strong>装饰器是“用一个函数装饰另外一个函数并为其提供额外的能力”的语法。装饰器本身是一个函数，它的参数是被装饰的函数，它的返回值是一个带有装饰功能的函数。装饰器是高阶函数，它的参数和返回值都是函数。</strong></p>
<p><strong>Python万物皆对象，也就是万物都可传参,函数也可以作为函数的参数进行传递。还要强调一下，Python 语言支持函数的嵌套定义，可以在一个函数中定义另一个函数，这个操作在很多编程语言中并不被支持。</strong></p>
<blockquote>
<p>装饰器给现有的模块增添新的小功能，可以对原函数进行功能扩展，不需要修改原函数的内容，也不需要修改原函数的调用情况</p>
</blockquote>
<p><strong>装饰器</strong> 在不修改函数本身的情况下，动态地增加或修改函数的行为。装饰器本质上也是一个函数，<strong>它接收一个函数作为参数输入，并在不改变原函数代码的情况下，返回一个增强的函数</strong>。核心思想是“<strong>函数是第一类对象</strong>”，即函数可以作为参数传递和返回。</p>
<p>装饰器要写在具体应用的函数前面，否则会报错；<strong>要先定义装饰器，才能在具体函数上面使用”@”装饰</strong>，在下面的示例中：</p>
<ul>
<li><code>decorator</code> 是装饰器函数，接受一个原函数 <code>func</code> 作为参数。</li>
<li><code>wrapper</code> 是在装饰器内部定义的一个新函数，它在执行原始函数 <code>func</code> 之前和之后添加了自定义的功能。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 由于要用wrapper替代原函数func，但是又不清楚原函数func会接受哪些参数，所以就通过可变参数和关键字参数照单全收，</span><br><span class="line"># 然后在调用func的时候，原封不动的全部给它</span><br><span class="line">def decorator(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&quot;Before function call&quot;)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(&quot;After function call&quot;)</span><br><span class="line">        return result</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"># 两种使用装饰器的方式</span><br><span class="line"># 第一种，直接调用装饰器函数</span><br><span class="line">func = decorator(func)</span><br><span class="line"># 第二种，语法糖</span><br><span class="line">@decorator</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>如果在代码的某些地方，想去掉装饰器的作用执行原函数，那么在定义装饰器函数的时候，需要做一点点额外的工作。Python 标准库<code>functools</code>模块的<code>wraps</code>函数也是一个装饰器，将它放在<code>wrapper</code>函数上，这个装饰器可以保留被装饰之前的函数，这样在需要取消装饰器时，可以通过被装饰函数的<code>__wrapped__</code>属性获得被装饰之前的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def record_time(func):</span><br><span class="line"></span><br><span class="line">    @wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(f&#x27;&#123;func.__name__&#125;执行时间: &#123;end - start:.2f&#125;秒&#x27;)</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@record_time</span><br><span class="line">def download(filename):</span><br><span class="line">    print(f&#x27;开始下载&#123;filename&#125;.&#x27;)</span><br><span class="line">    time.sleep(random.random() * 6)</span><br><span class="line">    print(f&#x27;&#123;filename&#125;下载完成.&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@record_time</span><br><span class="line">def upload(filename):</span><br><span class="line">    print(f&#x27;开始上传&#123;filename&#125;.&#x27;)</span><br><span class="line">    time.sleep(random.random() * 8)</span><br><span class="line">    print(f&#x27;&#123;filename&#125;上传完成.&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用装饰后的函数会记录执行时间</span><br><span class="line">download(&#x27;MySQL从删库到跑路.avi&#x27;)</span><br><span class="line">upload(&#x27;Python从入门到住院.pdf&#x27;)</span><br><span class="line"># 取消装饰器的作用不记录执行时间</span><br><span class="line">download.__wrapped__(&#x27;MySQL必知必会.pdf&#x27;)</span><br><span class="line">upload.__wrapped__(&#x27;Python从新手到大师.pdf&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>装饰器函数本身也是一个函数，既然是函数，就可以进行参数传递，如何写一个带参数的装饰器呢？</p>
<p>上例的装饰器只实现了计数功能，如果想在使用该装饰器的时候，传入一些备注的msg信息，应该怎么做？</p>
<p>基于原来的<code>count_time</code>函数外部<strong>再包一层用于接收参数的count_time_args</strong>，接收回来的参数就可以直接在内部的函数里面调用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def count_time_args(msg=None):</span><br><span class="line">    def count_time(func):</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            t1 = time.time()</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            print(f&quot;[&#123;msg&#125;]执行时间为：&quot;, time.time() - t1)</span><br><span class="line">            return func</span><br><span class="line">        return wrapper</span><br><span class="line">    return count_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@count_time_args(msg=&quot;baiyu&quot;)</span><br><span class="line">def fun_one():</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@count_time_args(msg=&quot;zhh&quot;)</span><br><span class="line">def fun_two():</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@count_time_args(msg=&quot;mylove&quot;)</span><br><span class="line">def fun_three():</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    fun_one()</span><br><span class="line">    fun_two()</span><br><span class="line">    fun_three()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"># 输出</span><br><span class="line">[baiyu]执行时间为： 1.0023813247680664</span><br><span class="line">[zhh]执行时间为： 1.0086195468902588</span><br><span class="line">[mylove]执行时间为： 1.004340410232544</span><br></pre></td></tr></table></figure>

<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>类装饰器其实就是一个实现了 <code>__call__()</code> 方法的类，它可以像<strong>函数装饰器</strong>一样使用 <code>@</code> 类名来修饰其他函数或类，使实例可调用，从而充当装饰器</p>
<p>🔹 <strong>类装饰器的本质</strong>：</p>
<ol>
<li>类被用作装饰器，必须实现 <code>__call__()</code> 方法。</li>
<li><code>__call__()</code> 方法会在被装饰函数调用时执行。</li>
<li><strong>可以保持状态</strong>（相比于函数装饰器）。</li>
</ol>
<p>类装饰器的实现是调用了类里面的__call__函数。类装饰器的写法比装饰器函数的写法更加简单。</p>
<p>当将类作为一个装饰器，工作流程如下：</p>
<ul>
<li>通过<code>__init__（）</code>方法初始化类</li>
<li>通过<code>__call__（）</code>方法调用真正的装饰方法</li>
</ul>
<blockquote>
<p>在下面的示例中</p>
</blockquote>
<ul>
<li><p>CounterDecorator 的 <code>__init__</code> 接收被装饰函数 say_hello（在构造函数中传入被装饰的函数）。</p>
</li>
<li><p><code>__call__</code> 使实例可调用，记录调用次数并执行原始函数。</p>
</li>
<li><p>@CounterDecorator 等价于 say_hello &#x3D; CounterDecorator(say_hello)。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class CounterDecorator:</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self.func = func  # 保存被装饰函数</span><br><span class="line">        self.count = 0    # 记录调用次数</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        self.count += 1</span><br><span class="line">        print(f&quot;Function &#x27;&#123;self.func.__name__&#125;&#x27; has been called &#123;self.count&#125; time(s)&quot;)</span><br><span class="line">        return self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"># 使用类装饰器</span><br><span class="line">@CounterDecorator</span><br><span class="line">def say_hello(name):</span><br><span class="line">    print(f&quot;Hello, &#123;name&#125;!&quot;)</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">say_hello(&quot;Alice&quot;)</span><br><span class="line">say_hello(&quot;Bob&quot;)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">Function &#x27;say_hello&#x27; has been called 1 time(s)</span><br><span class="line">Hello, Alice!</span><br><span class="line">Function &#x27;say_hello&#x27; has been called 2 time(s)</span><br><span class="line">Hello, Bob!</span><br></pre></td></tr></table></figure>

<h2 id="带参数的类装饰器"><a href="#带参数的类装饰器" class="headerlink" title="带参数的类装饰器"></a>带参数的类装饰器</h2><p>当装饰器包含参数的时候，就不能在<code>__init__()</code> 函数里传入<code>func</code>（要装饰的函数）了，而是将要装饰的函数<code>func</code>改为在<code>__call__()</code>函数调用的时候传入。</p>
<p>带参数的类装饰器允许向装饰器传递参数，如配置选项或自定义行为。实现方式通常是多层嵌套：外层类接受参数，内层类或方法处理被装饰函数,最后返回一个可调用对象。</p>
<blockquote>
<p>在下面的示例中:</p>
</blockquote>
<ul>
<li><p>LogDecorator 的 <code>__init__</code> 接受 prefix 和 max_calls 参数。</p>
</li>
<li><p><code>__call__</code> 接收被装饰函数 add，返回 wrapper 函数。</p>
</li>
<li><p>wrapper 检查调用次数，添加日志前缀并限制最大调用。</p>
</li>
<li><p>@LogDecorator(prefix&#x3D;”DEBUG”, max_calls&#x3D;3) 传递参数，创建装饰器实例。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class LogDecorator:</span><br><span class="line">    def __init__(self, prefix, max_calls=5):</span><br><span class="line">        self.prefix = prefix    # 日志前缀</span><br><span class="line">        self.max_calls = max_calls  # 最大调用次数</span><br><span class="line">        self.call_count = 0     # 当前调用次数</span><br><span class="line"></span><br><span class="line">    def __call__(self, func):</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            self.call_count += 1</span><br><span class="line">            if self.call_count &gt; self.max_calls:</span><br><span class="line">                print(f&quot;&#123;self.prefix&#125; Error: Maximum calls (&#123;self.max_calls&#125;) exceeded!&quot;)</span><br><span class="line">                return None</span><br><span class="line">            print(f&quot;&#123;self.prefix&#125; Calling &#x27;&#123;func.__name__&#125;&#x27; (Call &#123;self.call_count&#125;)&quot;)</span><br><span class="line">            return func(*args, **kwargs)</span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line"># 使用带参数的类装饰器</span><br><span class="line">@LogDecorator(prefix=&quot;DEBUG&quot;, max_calls=3)</span><br><span class="line">def add(a, b):</span><br><span class="line">    return a + b</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">print(add(1, 2))  # Call 1</span><br><span class="line">print(add(3, 4))  # Call 2</span><br><span class="line">print(add(5, 6))  # Call 3</span><br><span class="line">print(add(7, 8))  # Exceeds max_calls</span><br></pre></td></tr></table></figure>

<h2 id="装饰器的顺序"><a href="#装饰器的顺序" class="headerlink" title="装饰器的顺序"></a>装饰器的顺序</h2><blockquote>
<p>一个函数可以被多个装饰器进行装饰，那么装饰器的执行顺序是怎么样的？</p>
<p>由输出结果可知，在装饰器修饰完的函数，在执行的时候先执行原函数的功能，然后再<strong>由里到外</strong>(从下到上)依次执行装饰器的内容。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def BaiyuDecorator_1(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        print(&#x27;我是装饰器1&#x27;)</span><br><span class="line"> </span><br><span class="line">    return wrapper</span><br><span class="line"> </span><br><span class="line">def BaiyuDecorator_2(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        print(&#x27;我是装饰器2&#x27;)</span><br><span class="line"> </span><br><span class="line">    return wrapper</span><br><span class="line"> </span><br><span class="line">def BaiyuDecorator_3(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        print(&#x27;我是装饰器3&#x27;)</span><br><span class="line"> </span><br><span class="line">    return wrapper</span><br><span class="line"> </span><br><span class="line">@BaiyuDecorator_1</span><br><span class="line">@BaiyuDecorator_2</span><br><span class="line">@BaiyuDecorator_3</span><br><span class="line">def baiyu():</span><br><span class="line">    print(&quot;我是攻城狮白玉&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    baiyu()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/image-20250320000856918.png" alt="运行结果"></p>
<h2 id="框架中的装饰器"><a href="#框架中的装饰器" class="headerlink" title="框架中的装饰器"></a>框架中的装饰器</h2><p>在FastAPI框架中的 <code>@app.router()</code> 装饰器，它们和 Python 中常见的装饰器一样，本质上通过 <code>@</code> 符号修饰目标函数，但是它们的上下文通常与特定的框架有关，用于实现框架内部的功能（如 HTTP 路由）；</p>
<p>一些框架（如 <strong>Flask</strong> 或 <strong>FastAPI</strong> 等）也使用了类似的装饰器语法来定义路由。这里的 <code>@app.router()</code> 也是一个装饰器，它的作用是将一个函数绑定到特定的 HTTP 路由上。当访问该路由时，框架会调用装饰器绑定的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from fastapi import FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">@app.get(&quot;/&quot;)</span><br><span class="line">def read_root():</span><br><span class="line">    return &#123;&quot;message&quot;: &quot;Hello, World!&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/image-20250320003705586.png" alt="总结"></p>
<h2 id="经典的Python装饰器"><a href="#经典的Python装饰器" class="headerlink" title="经典的Python装饰器"></a>经典的Python装饰器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#  计时装饰器，可以用来测量函数执行时间。</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timing_decorator(func):</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(f&quot;&#123;func.__name__&#125; took &#123;end - start&#125; seconds to execute&quot;)</span><br><span class="line">        return result</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@timing_decorator</span><br><span class="line">def example_function():</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">example_function()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日志记录装饰器，用于在函数调用前后打印日志信息。</span><br><span class="line">def logging_decorator(func):</span><br><span class="line">	def wrapper(*args, **kwargs):</span><br><span class="line">        print(f&quot;Calling function: &#123;func.__name__&#125;&quot;)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(f&quot;Function &#123;func.__name__&#125; finished executing.&quot;)</span><br><span class="line">		return result</span><br><span class="line">	return wrapper</span><br><span class="line"> </span><br><span class="line">@logging_decorator</span><br><span class="line">def another_example():</span><br><span class="line">	pass</span><br><span class="line"> </span><br><span class="line">another_example()</span><br><span class="line"></span><br><span class="line"># 类装饰器</span><br><span class="line">def add_extra_attribute(cls):</span><br><span class="line">    cls.extra_attribute = &quot;This is an extra attribute.&quot;</span><br><span class="line">    return cls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@add_extra_attribute</span><br><span class="line">class MyClass:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">instance = MyClass()</span><br><span class="line">print(instance.extra_attribute)</span><br></pre></td></tr></table></figure>

<h1 id="类方法-静态方法-抽象方法"><a href="#类方法-静态方法-抽象方法" class="headerlink" title="类方法&amp;静态方法&amp;抽象方法"></a>类方法&amp;静态方法&amp;抽象方法</h1><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p><strong>类方法是属于类的方法</strong>，而不是类的某个实例。它接收的第一个参数通常是<strong>类本身</strong>，而不是实例。在Python中，使用<code>@classmethod</code>装饰器来定义类方法。</p>
<p>使用类方法来实例化对象，作为 <code>__init__()</code> 的替代或补充，是一种非常常见且推荐的模式。这种模式被称为工厂方法（Factory Method）。<strong>类方法</strong>充当了一个方便的“工厂”，它接收一个参数输入，然后在内部进行必要的处理、转换或验证，最终调用 类本身的<code>__init__</code> 来完成实际的实例创建。这是 Python 中一种非常优雅和实用的设计模式，尤其在处理复杂对象创建逻辑时，它能大大提升代码的清晰度、可读性和可维护性。</p>
<blockquote>
<p>特点</p>
</blockquote>
<ul>
<li><p><strong>第一个参数是类本身</strong>：惯例上，第一个参数名为<code>cls</code>（Class的缩写），代表调用该方法的类，在调用类方法时不需要在参数列表上加<code>cls</code>，Python解释器会自动添加，就像类方法不需要自己添加<code>self</code>一样。</p>
</li>
<li><p><strong>可以通过类或实例调用</strong>：无论是通过<code>ClassName.method()</code>还是<code>instance.method()</code>，<code>cls</code>参数都指向<code>ClassName</code>本身。</p>
</li>
<li><p><strong>主要用途</strong>：常用于创建<strong>工厂方法</strong>（Factory Methods），即根据不同的参数创建类的实例。还可以用于定义一些与类相关但不需要实例状态的操作。<strong>提供了一种替代构造函数的方式，可以添加自定义逻辑（例如验证 data 或转换格式）。</strong></p>
</li>
</ul>
<p>假设有一个<code>Circle</code>类，可以使用类方法来创建一个以特定半径或直径初始化的圆。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Circle:</span><br><span class="line">    pi = 3.14159</span><br><span class="line"></span><br><span class="line">    def __init__(self, radius):</span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_diameter(cls, diameter):</span><br><span class="line">        # cls represent the Circle class</span><br><span class="line">        radius = diameter / 2</span><br><span class="line">        return cls(radius)  # Create a new Circle instance</span><br><span class="line"></span><br><span class="line">    def area(self):</span><br><span class="line">        return self.pi * (self.radius ** 2)</span><br><span class="line"></span><br><span class="line"># 使用类方法创建实例</span><br><span class="line">c1 = Circle(5)  # radius = 5</span><br><span class="line">c2 = Circle.from_diameter(10)  # diameter = 10, radius = 5</span><br><span class="line"></span><br><span class="line">print(c1.area())  # 78.53975</span><br><span class="line">print(c2.area())  # 78.53975</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体应用场景</p>
</blockquote>
<p>类方法最适合用作工厂方法 (Factory Methods)。<strong>当一个类有多种不同的方式来创建实例时</strong>，类方法能让代码更清晰，也更符合面向对象的设计原则。</p>
<p>假设正在开发一个用户管理系统，<code>User</code> 类是核心。用户数据可能来自不同的地方，比如<strong>字典</strong>（通常是JSON或数据库查询结果）或者一个<strong>带分隔符的字符串</strong>（比如从CSV文件读取）。可以使用类方法来处理这些不同的数据来源。</p>
<p>如果用普通方法实现，可能需要编写像<code>create_user_from_dict()</code>这样的独立函数，或者在<code>__init__</code>中用复杂的条件判断来处理不同类型的数据。使用<strong>类方法</strong>则将这些创建逻辑清晰地组织在<code>User</code>类内部，使得代码更易读、更符合单一职责原则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class User:</span><br><span class="line">    def __init__(self, user_id, name, email):</span><br><span class="line">        self.user_id = user_id</span><br><span class="line">        self.name = name</span><br><span class="line">        self.email = email</span><br><span class="line">    </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return f&quot;User(id=&#123;self.user_id&#125;, name=&#x27;&#123;self.name&#125;&#x27;, email=&#x27;&#123;self.email&#125;&#x27;)&quot;</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_dict(cls, data):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        工厂方法：从字典创建User实例</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # cls在这里就是User类本身</span><br><span class="line">        return cls(data[&#x27;id&#x27;], data[&#x27;name&#x27;], data[&#x27;email&#x27;])</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_string(cls, data_string):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        工厂方法：从带分隔符的字符串创建User实例</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        user_id, name, email = data_string.split(&#x27;|&#x27;)</span><br><span class="line">        return cls(int(user_id), name, email)</span><br><span class="line"></span><br><span class="line"># 场景一：从字典创建用户</span><br><span class="line">user_data_dict = &#123;&#x27;id&#x27;: 101, &#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;email&#x27;: &#x27;alice@example.com&#x27;&#125;</span><br><span class="line">user1 = User.from_dict(user_data_dict)</span><br><span class="line">print(user1)</span><br><span class="line"># 输出：User(id=101, name=&#x27;Alice&#x27;, email=&#x27;alice@example.com&#x27;)</span><br><span class="line"></span><br><span class="line"># 场景二：从字符串创建用户</span><br><span class="line">user_data_string = &#x27;102|Bob|bob@example.com&#x27;</span><br><span class="line">user2 = User.from_string(user_data_string)</span><br><span class="line">print(user2)</span><br><span class="line"># 输出：User(id=102, name=&#x27;Bob&#x27;, email=&#x27;bob@example.com&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>静态方法是一种与类相关联，但<strong>不依赖于类或实例状态</strong>的方法。它不接收<code>cls</code>或<code>self</code>作为第一个参数。在Python中，使用<code>@staticmethod</code>装饰器来定义静态方法。</p>
<blockquote>
<p>特点</p>
</blockquote>
<ul>
<li><p><strong>没有默认参数</strong>：不需要接收<code>self</code>或<code>cls</code>，它的行为就像一个普通的函数，只是它被<strong>归属于类的命名空间</strong>。</p>
</li>
<li><p><strong>可以通过类或实例调用</strong>：调用方式与类方法类似，<strong>但它无法访问类或实例的属性或方法</strong>。</p>
</li>
<li><p><strong>主要用途</strong>：用于存放与类逻辑相关但又<strong>不依赖于任何类或实例数据</strong>的工具函数。这使得代码结构更清晰，将相关功能组织在一起。</p>
</li>
</ul>
<p>可以为<code>Circle</code>类添加一个静态方法来计算两个数的平均值，这个函数与<code>Circle</code>本身无关，但我们可以将其归入<code>Circle</code>的命名空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Circle:</span><br><span class="line">    pi = 3.14159</span><br><span class="line"></span><br><span class="line">    def __init__(self, radius):</span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def calculate_average(a, b):</span><br><span class="line">        return (a + b) / 2</span><br><span class="line"></span><br><span class="line"># 使用类调用静态方法</span><br><span class="line">avg = Circle.calculate_average(10, 20)</span><br><span class="line">print(avg)  # 15.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体应用场景</p>
</blockquote>
<p>假设正在开发一个密码管理工具，<code>PasswordManager</code>类负责存储和验证密码。需要一个函数来检查密码的强度。这个检查逻辑独立于任何具体的<code>PasswordManager</code>实例，它只关心输入的字符串本身。</p>
<p>如果将<code>is_strong_password</code>作为一个独立的函数放在类的外部，代码结构会显得分散。将其作为<strong>静态方法</strong>，可以清楚地表明这个工具函数是专为<code>PasswordManager</code>类服务的，增强代码的内聚性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class PasswordManager:</span><br><span class="line">    # 这里有存储和管理密码的逻辑...</span><br><span class="line">    </span><br><span class="line">    @staticmethod</span><br><span class="line">    def is_strong_password(password):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        静态方法：检查密码是否符合强度要求</span><br><span class="line">        这个方法不依赖于PasswordManager的任何实例或类属性</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 实际的密码强度检查会更复杂</span><br><span class="line">        if len(password) &lt; 8:</span><br><span class="line">            return False</span><br><span class="line">        if not any(char.isdigit() for char in password):</span><br><span class="line">            return False</span><br><span class="line">        if not any(char.isupper() for char in password):</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line"># 检查一个密码的强度，无需创建PasswordManager实例</span><br><span class="line">password_to_check = &quot;MySecureP@ss123&quot;</span><br><span class="line">if PasswordManager.is_strong_password(password_to_check):</span><br><span class="line">    print(&quot;密码强度符合要求。&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;密码强度不足。&quot;)</span><br><span class="line"></span><br><span class="line"># 输出：密码强度符合要求。</span><br></pre></td></tr></table></figure>

<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>抽象方法是一个<strong>声明了但没有具体实现</strong>的方法。它必须在<strong>抽象基类</strong>（Abstract Base Class，简称ABC）中定义。子类继承这个抽象基类后，<strong>必须实现</strong>这个抽象方法，否则子类无法被实例化。在Python中，使用<code>abc</code>模块的<code>ABC</code>类和<code>@abstractmethod</code>装饰器来实现</p>
<blockquote>
<p>特点</p>
</blockquote>
<ul>
<li><p><strong>必须在子类中实现</strong>：抽象方法强制子类提供特定的实现，这有助于定义一个公共接口，其实就是相当于java中的<code>interface</code> 接口关键字。</p>
</li>
<li><p><strong>强制实现</strong>：如果子类没有实现所有的抽象方法，那么创建子类的实例会引发<code>TypeError</code>。</p>
</li>
<li><p><strong>主要用途</strong>：用于创建<strong>接口（Interface）或模板</strong>。它定义了一个类的蓝图，强制所有继承它的子类遵循相同的结构，方便后续进一步开发与规范。</p>
</li>
</ul>
<p>假设正在构建一个图形绘制程序，可以创建一个<code>Shape</code>抽象基类，并定义一个抽象方法<code>draw()</code>。所有具体的图形类（如<code>Circle</code>、<code>Square</code>）都必须实现<code>draw()</code>方法，才能进行后续的类实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line">class Shape(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def draw(self):</span><br><span class="line">        pass  # No implementation here</span><br><span class="line"></span><br><span class="line">class Circle(Shape):</span><br><span class="line">    def draw(self):</span><br><span class="line">        print(&quot;Drawing a circle.&quot;)</span><br><span class="line"></span><br><span class="line">class Square(Shape):</span><br><span class="line">    def draw(self):</span><br><span class="line">        print(&quot;Drawing a square.&quot;)</span><br><span class="line"></span><br><span class="line"># 直接实例化抽象类会失败</span><br><span class="line"># s = Shape() # TypeError: Can&#x27;t instantiate abstract class Shape with abstract method draw</span><br><span class="line"></span><br><span class="line"># 正确的实例化方式</span><br><span class="line">circle = Circle()</span><br><span class="line">square = Square()</span><br><span class="line"></span><br><span class="line">circle.draw()  # Drawing a circle.</span><br><span class="line">square.draw() # Drawing a square.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体应用场景</p>
</blockquote>
<p> 抽象方法用于<strong>定义一个公共的接口</strong>。它强制所有继承自抽象基类的子类必须实现该方法，从而确保不同子类都具有相同的行为。</p>
<p>假设正在开发一个文件处理器系统，需要处理不同类型的文件，比如<code>PDF</code>、<code>Word</code>、<code>Text</code>等。虽然每种文件的处理方式不同，但它们都必须有一个<code>read</code>方法来读取内容和一个<code>save</code>方法来保存。抽象方法可以定义这个通用的<strong>处理接口</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABC, abstractmethod</span><br><span class="line"></span><br><span class="line">class FileProcessor(ABC):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    抽象基类，定义文件处理的公共接口</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, filepath):</span><br><span class="line">        self.filepath = filepath</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def read_content(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        抽象方法：子类必须实现如何读取文件内容</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abstractmethod</span><br><span class="line">    def save_content(self, content):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        抽象方法：子类必须实现如何保存文件内容</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class PDFProcessor(FileProcessor):</span><br><span class="line">    def read_content(self):</span><br><span class="line">        print(f&quot;正在读取PDF文件：&#123;self.filepath&#125;&quot;)</span><br><span class="line">        # 实际代码会使用PDF解析库</span><br><span class="line">        return &quot;PDF文件内容...&quot;</span><br><span class="line"></span><br><span class="line">    def save_content(self, content):</span><br><span class="line">        print(f&quot;正在保存PDF文件：&#123;self.filepath&#125;&quot;)</span><br><span class="line">        # 实际代码会使用PDF生成库</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class TextProcessor(FileProcessor):</span><br><span class="line">    def read_content(self):</span><br><span class="line">        print(f&quot;正在读取TXT文件：&#123;self.filepath&#125;&quot;)</span><br><span class="line">        # 实际代码会读取文本文件</span><br><span class="line">        return &quot;TXT文件内容...&quot;</span><br><span class="line"></span><br><span class="line">    def save_content(self, content):</span><br><span class="line">        print(f&quot;正在保存TXT文件：&#123;self.filepath&#125;&quot;)</span><br><span class="line">        # 实际代码会写入文本文件</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"># 使用抽象类定义的接口来处理不同文件</span><br><span class="line">pdf_file = PDFProcessor(&quot;document.pdf&quot;)</span><br><span class="line">text_file = TextProcessor(&quot;note.txt&quot;)</span><br><span class="line"></span><br><span class="line">pdf_content = pdf_file.read_content()</span><br><span class="line">text_content = text_file.read_content()</span><br><span class="line"></span><br><span class="line">pdf_file.save_content(&quot;新的PDF内容&quot;)</span><br><span class="line">text_file.save_content(&quot;新的TXT内容&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><hr>
<table>
<thead>
<tr>
<th>特性</th>
<th>类方法 (Class Method)</th>
<th>静态方法 (Static Method)</th>
<th>抽象方法 (Abstract Method)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>装饰器</strong></td>
<td><code>@classmethod</code></td>
<td><code>@staticmethod</code></td>
<td><code>@abstractmethod</code></td>
</tr>
<tr>
<td><strong>第一个参数</strong></td>
<td><code>cls</code> (类本身)</td>
<td>无</td>
<td>无（但在子类中实现时通常包含<code>self</code>或<code>cls</code>）</td>
</tr>
<tr>
<td><strong>访问能力</strong></td>
<td>能够访问类的属性和方法</td>
<td>不能访问类或实例的属性和方法</td>
<td>强制子类实现，行为由子类决定</td>
</tr>
<tr>
<td><strong>主要用途</strong></td>
<td>工厂方法，处理与类相关但不需要实例状态的操作，替代或扩展构造函数</td>
<td>组织与类逻辑相关但不依赖于任何类或实例数据的工具函数</td>
<td>定义接口或模板，强制子类遵循特定结构</td>
</tr>
<tr>
<td><strong>调用方式</strong></td>
<td><code>ClassName.method()</code> 或 <code>instance.method()</code></td>
<td><code>ClassName.method()</code> 或 <code>instance.method()</code></td>
<td>在子类中实现后通过<code>instance.method()</code>调用</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 使用类方法替代构造方法的示例</span><br><span class="line">class MyClass:</span><br><span class="line">    @classmethod</span><br><span class="line">    def from_data(cls, data):</span><br><span class="line">        return cls(data)</span><br><span class="line"></span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        print(self.data)</span><br><span class="line"></span><br><span class="line"># 使用类方法新建类实例</span><br><span class="line">obj = MyClass.from_data(&quot;test&quot;)</span><br><span class="line">print(obj.data)  # 输出: test</span><br><span class="line"></span><br><span class="line"># 使用构造方法新建类实例</span><br><span class="line">obj_2 = MyClass(&#x27;test2&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h1><p><strong>lambda 函数</strong>也称为 <strong>匿名函数</strong>，使用 <code>lambda</code> 关键字定义。主要包含以下特点：</p>
<ul>
<li><p><strong>匿名性：</strong> 没有函数名，无需 <code>def</code> 和函数名定义。</p>
</li>
<li><p><strong>简洁性：</strong> <strong>只能包含一个表达式，这个表达式的执行结果就是函数的返回值</strong>（important！！！）</p>
</li>
<li><p><strong>即时性：</strong> 通常用于一次性使用的简单操作，无需定义一个完整的函数。</p>
</li>
</ul>
<blockquote>
<p>Lambda 函数的语法</p>
</blockquote>
<p><code>lambda 参数1, 参数2, ... : 表达式</code></p>
<ul>
<li><p><code>lambda</code>: 关键字，表示这是一个 lambda 函数。</p>
</li>
<li><p><code>arguments</code>: 函数的参数列表，可以有0个或多个参数，使用逗号进行分隔。</p>
</li>
<li><p><code>expression</code>: <code>lambda</code> 函数的“函数体”。它必须是一个<strong>单一的表达式</strong>，其计算结果就是 lambda 函数的返回值。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 无参数的 lambda 表达式</span><br><span class="line">greet = lambda: print(&quot;Hello, World!&quot;)</span><br><span class="line"></span><br><span class="line"># 调用 lambda 函数</span><br><span class="line">greet()</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<h2 id="lambda-函数常见使用场景"><a href="#lambda-函数常见使用场景" class="headerlink" title="lambda 函数常见使用场景"></a>lambda 函数常见使用场景</h2><blockquote>
<p>作为高阶函数的参数</p>
</blockquote>
<p>常用于 <code>map()</code>、<code>filter()</code>、<code>sorted()</code> 等函数式编程场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 1. 基本数学运算</span><br><span class="line">add = lambda x, y: x + y</span><br><span class="line">print(add(2, 3))  # 输出 5</span><br><span class="line"></span><br><span class="line"># 2. 结合 map() 处理列表</span><br><span class="line">numbers = [1, 2, 3, 4]</span><br><span class="line">squares = list(map(lambda x: x**2, numbers))</span><br><span class="line">print(squares)  # 输出 [1, 4, 9, 16]</span><br><span class="line"></span><br><span class="line"># 3. 结合 filter() 筛选数据，lambda的返回值是True or False，filter() 会保留返回为 True 的元素</span><br><span class="line">evens = list(filter(lambda x: x % 2 == 0, numbers))</span><br><span class="line">print(evens)  # 输出 [2, 4]</span><br><span class="line"></span><br><span class="line"># 4. 结合 sorted() 自定义排序，按元组的第二个元素（字符串）排序，排序是基于字符串的 ASCII 码按字典序升序进行的。</span><br><span class="line">pairs = [(1, &#x27;one&#x27;), (3, &#x27;three&#x27;), (2, &#x27;two&#x27;)]</span><br><span class="line">sorted_pairs = sorted(pairs, key=lambda x: x[1])</span><br><span class="line">print(sorted_pairs)  # 输出 [(1, &#x27;one&#x27;), (3, &#x27;three&#x27;), (2, &#x27;two&#x27;)]</span><br><span class="line"></span><br><span class="line"># 5. 条件表达式</span><br><span class="line">is_positive = lambda x: &quot;Positive&quot; if x &gt; 0 else &quot;Non-positive&quot;</span><br><span class="line">print(is_positive(5))  # 输出 Positive</span><br><span class="line">print(is_positive(-1))  # 输出 Non-positive</span><br><span class="line"></span><br><span class="line"># 6. 嵌套 Lambda（函数组合）</span><br><span class="line">compose = lambda x: (lambda y: x + y)(10)</span><br><span class="line">print(compose(5))  # 输出 15</span><br></pre></td></tr></table></figure>

<blockquote>
<p>lambda 函数可以返回一个元组，这样它看起来就好像返回了多个值</p>
</blockquote>
<p><strong>lambda 函数永远只有一个返回值</strong>。这是它设计上的一个核心限制。任何一个表达式求值的结果都只会是<strong>一个值</strong>。如果一个<code>lambda</code>函数有“多个返回值”时，它实际上并非返回了多个独立的值，而是返回了一个**元组 (tuple)**。这个元组包含了返回的所有“值”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">calculate_power_lambda = lambda x: (x * x, x * x * x)</span><br><span class="line"></span><br><span class="line"># 调用 lambda 函数，并将返回的元组解包</span><br><span class="line">result_square_l, result_cube_l = calculate_power_lambda(4)</span><br><span class="line">print(f&quot;Lambda 函数平方: &#123;result_square_l&#125;, 立方: &#123;result_cube_l&#125;&quot;)</span><br><span class="line"># 输出: Lambda 函数平方: 16, 立方: 64</span><br><span class="line"></span><br><span class="line"># 或者不解包，直接看返回值</span><br><span class="line">single_return_value_from_lambda = calculate_power_lambda(4)</span><br><span class="line">print(f&quot;Lambda 函数的实际返回值类型: &#123;type(single_return_value_from_lambda)&#125;&quot;)</span><br><span class="line">print(f&quot;Lambda 函数的实际返回值: &#123;single_return_value_from_lambda&#125;&quot;)</span><br><span class="line"># 输出: Lambda 函数的实际返回值类型: &lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line"># 输出: Lambda 函数的实际返回值: (16, 64)</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 的表达式也可以是一个函数</strong>。Lambda 函数的表达式可以调用任何其他函数，<strong>并返回被调用函数的返回值作为lambda的返回值！！</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def multiply_by_ten(num):</span><br><span class="line">    return num * 10</span><br><span class="line"></span><br><span class="line">my_lambda = lambda x: multiply_by_ten(x)</span><br><span class="line"></span><br><span class="line">result = my_lambda(5)</span><br><span class="line">print(f&quot;Lambda 调用外部函数的结果: &#123;result&#125;&quot;) # 输出: Lambda 调用外部函数的结果: 50</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># case 2</span><br><span class="line">numbers = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">def add_one(n):</span><br><span class="line">    return n + 1</span><br><span class="line"></span><br><span class="line"># lambda 表达式中调用 add_one</span><br><span class="line">processed_numbers = list(map(lambda x: add_one(x), numbers))</span><br><span class="line">print(f&quot;map 结合 lambda 和函数调用: &#123;processed_numbers&#125;&quot;) # 输出: map 结合 lambda 和函数调用: [2, 3, 4]</span><br></pre></td></tr></table></figure>

<h1 id="Python解包"><a href="#Python解包" class="headerlink" title="Python解包"></a>Python解包</h1><p><code>解包</code>是Python中一项强大而实用的特性，<strong>它允许将容器类型（如列表、元组、字典等）中的元素拆解为独立变量或参数</strong>，从而简化代码并提高可读性。将可迭代对象（列表、元组、字典等）的元素直接赋值给多个变量，或在函数调用、循环等场景中展开元素。</p>
<ul>
<li><p><code>*</code> 在解包中只能使用一次。</p>
</li>
<li><p><code>**</code> 仅适用于字典，且键名需与函数参数匹配。</p>
</li>
</ul>
<blockquote>
<p>基本语法：variable1, variable2, … &#x3D; iterable</p>
</blockquote>
<h2 id="封包"><a href="#封包" class="headerlink" title="封包"></a>封包</h2><p>封包指的是，将多个值赋值给一个变量时，Python 会自动将这些值封包为一个元组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; count = 996, 123, -3</span><br><span class="line">&gt;&gt;&gt; count</span><br><span class="line">(996, 123, -3)</span><br></pre></td></tr></table></figure>

<h2 id="基础解包"><a href="#基础解包" class="headerlink" title="基础解包"></a>基础解包</h2><p>将可迭代对象（列表、元组、字符串等）中的元素按顺序分配给多个变量。</p>
<ul>
<li>变量数量必须与元素数量一致，否则会报错<code>ValueError</code>。</li>
<li>支持所有可迭代对象（列表、元组、字符串、集合等）。<strong>不可迭代对象解包会报错</strong>，<code>a, b = 100</code> </li>
<li>集合是无序结构，解包时变量接收元素的顺序可能与定义时不同。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 列表解包</span><br><span class="line">colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span><br><span class="line">red, blue, green = colors</span><br><span class="line">print(red)   # &#x27;red&#x27;</span><br><span class="line">print(blue)  # &#x27;blue&#x27;</span><br><span class="line"></span><br><span class="line"># 元组解包</span><br><span class="line">x, y = (10, 20)</span><br><span class="line">print(x)  # 10</span><br><span class="line">print(y)  # 20</span><br><span class="line"></span><br><span class="line"># 字符串解包</span><br><span class="line">a, b, c = &quot;abc&quot;</span><br><span class="line">print(b)  # &#x27;b&#x27;</span><br><span class="line"></span><br><span class="line"># 集合解包（顺序不确定）</span><br><span class="line">s = &#123;1, 2, 3&#125;</span><br><span class="line">a, b, c = s</span><br><span class="line">print(a, b, c)  # 可能输出 1 2 3 或 3 1 2 等</span><br></pre></td></tr></table></figure>

<h2 id="扩展解包"><a href="#扩展解包" class="headerlink" title="扩展解包"></a>扩展解包</h2><p>使用<code>*</code>操作符捕获多余元素，处理不定长序列。<code>*</code> 在解包中只能使用一次。</p>
<ul>
<li><code>*</code>变量始终返回列表，即使没有元素。</li>
<li><code>*</code>可以放在任意位置，收集剩余元素。</li>
<li>可以忽略不需要的元素：<code>a, *_, c = (1, 2, 3)</code>。</li>
<li>支持多层嵌套解包：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 捕获中间元素</span><br><span class="line">first, *middle, last = [1, 2, 3, 4, 5]</span><br><span class="line">print(middle)  # [2, 3, 4]</span><br><span class="line"></span><br><span class="line"># 处理任意长度序列</span><br><span class="line">a, *b = [10]</span><br><span class="line">print(a)  # 10</span><br><span class="line">print(b)  # []  # 空列表</span><br><span class="line"></span><br><span class="line"># case 2</span><br><span class="line">data = [</span><br><span class="line">    1,            # 第一层元素1</span><br><span class="line">    [2, 3, 4],    # 第二层列表</span><br><span class="line">    (5, 6)        # 第二层元组</span><br><span class="line">]</span><br><span class="line">a, (b, *c), d = data  </span><br><span class="line"># 解包第一层：a=1</span><br><span class="line"># 解包第二层列表得 b=2，*c收集剩余元素[3,4]</span><br><span class="line"># d实际接收元组(5,6)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)  # [3, 4]</span><br><span class="line">print(d)  # (5, 6)  # 元组未进一步解包，d仍是元组类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">[3, 4]</span><br><span class="line">(5, 6)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用*_忽略多余元素</span><br><span class="line">data = [1, 2, 3, 4, 5]</span><br><span class="line">a, b, *_ = data  # 只取前两个，忽略其余</span><br><span class="line"></span><br><span class="line"># 默认值处理</span><br><span class="line">values = [10, 20]</span><br><span class="line">x, y, *rest = values</span><br><span class="line">z = rest[0] if rest else None</span><br></pre></td></tr></table></figure>

<h2 id="字典解包"><a href="#字典解包" class="headerlink" title="字典解包"></a>字典解包</h2><p>字典解包默认解包的是键（key），不是值（value）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 字典键解包</span><br><span class="line">person = &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 25&#125;</span><br><span class="line">key1, key2 = person</span><br><span class="line">print(key1)  # &#x27;name&#x27;</span><br><span class="line">print(key2)  # &#x27;age&#x27;</span><br><span class="line"></span><br><span class="line"># 字典值解包（values()方法）</span><br><span class="line">person = &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 25&#125;</span><br><span class="line">value1, value2 = person.values()</span><br><span class="line">print(value1, value2)  # &#x27;张三&#x27; 25</span><br><span class="line"></span><br><span class="line"># 字典键值对解包（items()方法）</span><br><span class="line">for key, value in person.items():</span><br><span class="line">    print(f&quot;&#123;key&#125;: &#123;value&#125;&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="循环中的解包"><a href="#循环中的解包" class="headerlink" title="循环中的解包"></a>循环中的解包</h2><p>直接解包迭代器中的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 遍历元组列表</span><br><span class="line">points = [(1, 2), (3, 4), (5, 6)]</span><br><span class="line">for x, y in points:</span><br><span class="line">    print(f&quot;坐标：(&#123;x&#125;, &#123;y&#125;)&quot;)</span><br><span class="line"></span><br><span class="line"># 遍历字典项</span><br><span class="line">user_info = &#123;&quot;name&quot;: &quot;小帅&quot;, &quot;age&quot;: 30&#125;</span><br><span class="line">for key, value in user_info.items():</span><br><span class="line">    print(f&quot;&#123;key&#125;: &#123;value&#125;&quot;)</span><br><span class="line">    </span><br><span class="line"># 输出</span><br><span class="line">坐标：(1, 2)</span><br><span class="line">坐标：(3, 4)</span><br><span class="line">坐标：(5, 6)</span><br><span class="line">name: 小帅</span><br><span class="line">age: 30</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote>
<p>数据合并</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 合并多个列表</span><br><span class="line">list1 = [1, 2]</span><br><span class="line">list2 = [3, 4]</span><br><span class="line">combined = [*list1, *list2]  # [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"># 合并多个字典,后出现的键（dict2的z）覆盖前一个</span><br><span class="line">dict1 = &#123;&#x27;x&#x27;: 1, &#x27;z&#x27;: 3&#125;</span><br><span class="line">dict2 = &#123;&#x27;y&#x27;: 2, &#x27;z&#x27;: 4&#125;</span><br><span class="line">merged = &#123;**dict1, **dict2&#125;  # &#123;&#x27;x&#x27;: 1, &#x27;z&#x27;: 4, &#x27;y&#x27;: 2&#125;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>提取数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 提取首尾元素</span><br><span class="line">numbers = [10, 20, 30, 40]</span><br><span class="line">first, *_, last = numbers</span><br><span class="line">print(first, last)  # 10 40</span><br></pre></td></tr></table></figure>

<h1 id="Python高阶函数"><a href="#Python高阶函数" class="headerlink" title="Python高阶函数"></a>Python高阶函数</h1><p>高阶函数是指<strong>满足以下任意一个或同时满足两个条件的函数</strong>：</p>
<ol>
<li><strong>接受一个或多个函数作为参数（最常见）</strong>。</li>
<li><strong>返回一个函数作为结果</strong>。</li>
</ol>
<p>这使得函数可以像普通参数（如整数、字符串）一样被传递、赋值和操作。高阶函数（如 <code>map()</code>、<code>filter()</code>）适合大数据处理，但有些高阶函数的返回值可能是一个迭代器，需要用户自行显式转换为列表或元组，才能直接<code>print</code>出来，也可以使用<code>next()</code>一个个迭代来加载元素。</p>
<ul>
<li><code>map(function, iterable, ...)</code>：对可迭代对象的每个元素应用函数function，返回迭代器。</li>
<li><code>filter(function, iterable)</code>：筛选可迭代对象中满足函数function条件的元素，返回迭代器。</li>
<li><code>sorted(iterable, key=None, reverse=False)</code>：按 <code>key</code> 函数排序，返回一个新的列表。</li>
<li><code>reduce(function, iterable[, initializer])</code>：从 functools 模块，累计应用函数到可迭代对象。</li>
</ul>
<blockquote>
<p><code>map()</code> 函数</p>
</blockquote>
<p><strong>功能：</strong> 对可迭代对象中的每个元素应用同一个函数，并返回一个迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">numbers = [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">def square(x):</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line"># map 接受 square 函数和 numbers 列表作为参数,对numbers中的每一个元素执行square()操作</span><br><span class="line">squared_numbers = map(square, numbers)</span><br><span class="line">print(f&quot;map() 使用常规函数: &#123;list(squared_numbers)&#125;&quot;) # 输出: map() 使用常规函数: [1, 4, 9, 16, 25]</span><br><span class="line"></span><br><span class="line"># 常用结合 lambda 函数</span><br><span class="line">squared_numbers_lambda = map(lambda x: x * x, numbers)</span><br><span class="line">print(f&quot;map() 使用 lambda 函数: &#123;list(squared_numbers_lambda)&#125;&quot;) # 输出: map() 使用 lambda 函数: [1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>filter()</code> 函数</p>
</blockquote>
<p><strong>功能：</strong> 根据一个返回布尔值的函数来过滤可迭代对象中的元素，只保留使函数返回为 <code>True</code> 的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">numbers = [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">def is_even(x):</span><br><span class="line">    return x % 2 == 0</span><br><span class="line"></span><br><span class="line"># filter 接受 is_even 函数和 numbers 列表作为参数</span><br><span class="line">even_numbers = filter(is_even, numbers)</span><br><span class="line">print(f&quot;filter() 使用常规函数: &#123;list(even_numbers)&#125;&quot;) # 输出: filter() 使用常规函数: [2, 4, 6]</span><br><span class="line"></span><br><span class="line"># 常用结合 lambda 函数</span><br><span class="line">even_numbers_lambda = filter(lambda x: x % 2 == 0, numbers)</span><br><span class="line">print(f&quot;filter() 使用 lambda 函数: &#123;list(even_numbers_lambda)&#125;&quot;) # 输出: filter() 使用 lambda 函数: [2, 4, 6]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>sorted()</code> 函数</p>
</blockquote>
<p><strong>功能：</strong> 对可迭代对象进行排序，并可选地接受一个 <code>key</code> 参数，该参数是一个函数，用于生成可迭代对象中用于比较的键值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">students = [(&#x27;Alice&#x27;, 20), (&#x27;Bob&#x27;, 25), (&#x27;Charlie&#x27;, 18)]</span><br><span class="line"></span><br><span class="line"># sorted 接受 lambda 函数作为 key 参数</span><br><span class="line">sorted_by_age = sorted(students, key=lambda student: student[1])</span><br><span class="line">print(f&quot;sorted() 使用 lambda 作为 key: &#123;sorted_by_age&#125;&quot;) # 输出: sorted() 使用 lambda 作为 key: [(&#x27;Charlie&#x27;, 18), (&#x27;Alice&#x27;, 20), (&#x27;Bob&#x27;, 25)]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>functools.reduce()</code> 函数</strong> (需要导入)</p>
</blockquote>
<p><strong>功能：</strong> 对可迭代对象中的元素进行累积操作（例如求和、求积），从左到右依次将元素和上一次操作的结果传入一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line">numbers = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"># 定义一个函数来计算乘积</span><br><span class="line">def multiply(x, y):</span><br><span class="line">    return x * y</span><br><span class="line"></span><br><span class="line"># reduce 接受 multiply 函数和 numbers 列表作为参数</span><br><span class="line">product = reduce(multiply, numbers)</span><br><span class="line">print(f&quot;reduce() 使用常规函数: &#123;product&#125;&quot;) # 输出: reduce() 使用常规函数: 24 (1*2*3*4)</span><br><span class="line"></span><br><span class="line"># 常用结合 lambda 函数</span><br><span class="line">product_lambda = reduce(lambda x, y: x * y, numbers)</span><br><span class="line">print(f&quot;reduce() 使用 lambda 函数: &#123;product_lambda&#125;&quot;) # 输出: reduce() 使用 lambda 函数: 24</span><br></pre></td></tr></table></figure>

<h1 id="可迭代对象-迭代器-生成器"><a href="#可迭代对象-迭代器-生成器" class="headerlink" title="可迭代对象&amp;迭代器&amp;生成器"></a>可迭代对象&amp;迭代器&amp;生成器</h1><p><strong>迭代</strong>：通过for循环遍历对象的每一个元素的过程，字符串、列表、字典、元组、集合等都是可以迭代数据类型，也是可迭代对象。</p>
<h2 id="为什么有可迭代对象还不够，还需要迭代器"><a href="#为什么有可迭代对象还不够，还需要迭代器" class="headerlink" title="为什么有可迭代对象还不够，还需要迭代器?"></a>为什么有可迭代对象还不够，还需要迭代器?</h2><blockquote>
<p>总结：可迭代对象适合静态、小数据集，但内存占用高，灵活性有限。迭代器通过惰性求值和自定义逻辑，优化内存和性能，满足大数据、流处理和复杂遍历需求。</p>
</blockquote>
<p>迭代器（Iterator）在 Python 中用于逐个访问可迭代对象的元素，提供以下关键用途：</p>
<ol>
<li><strong>内存效率</strong>：迭代器一次只生成一个元素，适合处理大数据（如大文件或流式数据），不像列表将所有元素一次性加载到内存。</li>
<li><strong>惰性求值</strong>：按需生成数据，延迟计算，优化性能。</li>
<li><strong>单向遍历</strong>：支持一次遍历，适合单次处理场景（如日志分析）。</li>
<li><strong>自定义迭代</strong>：允许定义特定遍历逻辑（如跳跃、过滤）。</li>
<li><strong>流式处理</strong>：与生成器结合，处理实时或无限数据流。</li>
</ol>
<h3 id="为什么仅有可迭代对象不够？"><a href="#为什么仅有可迭代对象不够？" class="headerlink" title="为什么仅有可迭代对象不够？"></a>为什么仅有可迭代对象不够？</h3><p>可迭代对象（如列表、元组）可以通过 <strong>iter</strong>() 返回迭代器，但自身功能有限：</p>
<ol>
<li>内存占用：<ul>
<li>可迭代对象（如列表）一次性存储所有数据，内存开销大。</li>
<li>迭代器逐个生成数据，适合大文件或动态数据。</li>
</ul>
</li>
<li>灵活性不足：<ul>
<li>可迭代对象提供固定遍历顺序，无法动态调整。</li>
<li>迭代器通过 <strong>next</strong>() 可自定义遍历逻辑（如跳跃、条件过滤）。</li>
</ul>
</li>
<li>一次性遍历：<ul>
<li>可迭代对象可多次迭代，迭代器一次耗尽，适合临时数据处理。</li>
</ul>
</li>
<li>动态生成：<ul>
<li>可迭代对象通常是静态数据，迭代器（尤其是生成器）支持动态生成数据，如实时计算或流处理。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 可迭代对象：列表全加载</span><br><span class="line">lst = [x for x in range(1000000)]  # 占用大量内存</span><br><span class="line">for x in lst:  # 多次迭代</span><br><span class="line">    if x &gt; 5: break</span><br><span class="line">print(lst[0])  # 可重复访问</span><br><span class="line"></span><br><span class="line"># 迭代器：惰性生成</span><br><span class="line">class SkipIterator:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = 0</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &gt;= len(self.data):</span><br><span class="line">            raise StopIteration</span><br><span class="line">        value = self.data[self.index]</span><br><span class="line">        self.index += 2  # 自定义：跳跃遍历</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">it = SkipIterator([1, 2, 3, 4, 5])</span><br><span class="line">for x in it:  # 仅遍历 1, 3, 5</span><br><span class="line">    print(x)  # 输出 1 3 5</span><br></pre></td></tr></table></figure>

<p>在 Python 中，__iter__ 和 __next__ 是与迭代概念相关的魔术方法，用于实现<strong>可迭代对象</strong>和<strong>迭代器</strong>。</p>
<ol>
<li><code>__iter__</code> 方法</li>
</ol>
<ul>
<li><strong>作用</strong>：使对象成为<strong>可迭代对象</strong>，返回一个迭代器。</li>
<li><strong>定义</strong>：在类中定义 <code>__iter__(self)</code>，返回一个实现了 <code>__next__</code> 方法的迭代器对象（通常是 self）。</li>
<li><strong>调用时机</strong>：当对象用于 for 循环或 <code>iter()</code> 函数时，Python 调用 __iter__。</li>
</ul>
<ol start="2">
<li><code>__next__</code> 方法</li>
</ol>
<ul>
<li><strong>作用</strong>：定义迭代器的行为，返回下一个元素。</li>
<li><strong>定义</strong>：在类中定义 <code>__next__(self)</code>，每次调用返回迭代的下一个值，迭代结束时抛出 StopIteration 异常。</li>
<li><strong>调用时机</strong>：在迭代过程中，<code>next()</code> 函数或 for 循环会调用 <code>__next__</code>。</li>
</ul>
<h3 id="迭代器-Iterator-和-for-in-循环"><a href="#迭代器-Iterator-和-for-in-循环" class="headerlink" title="迭代器 (Iterator) 和 for ... in ... 循环"></a>迭代器 (Iterator) 和 <code>for ... in ...</code> 循环</h3><p>在 Python 中，<code>for ... in ...</code> 循环能够遍历任何**可迭代对象 (Iterable)**。当 <code>for</code> 循环遇到一个可迭代对象时，它会做以下几件事：</p>
<ol>
<li><strong>获取迭代器：</strong> 它会调用可迭代对象的 <code>__iter__()</code> 方法，从而获取一个<strong>迭代器 (Iterator)</strong> 对象。</li>
<li><strong>反复调用 <code>next()</code>：</strong> 循环会反复地调用这个迭代器的 <code>__next__()</code> 方法来获取下一个元素。</li>
<li><strong>捕获 <code>StopIteration</code>：</strong> 当迭代器没有更多元素时，它会抛出一个 <code>StopIteration</code> 异常。<code>for</code> 循环会捕获这个异常，并优雅地结束循环。</li>
</ol>
<h3 id="zip-函数的返回值：一个迭代器"><a href="#zip-函数的返回值：一个迭代器" class="headerlink" title="zip() 函数的返回值：一个迭代器"></a><code>zip()</code> 函数的返回值：一个迭代器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">products = [&#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Orange&#x27;]</span><br><span class="line">prices = [1.0, 0.5, 1.2]</span><br><span class="line"></span><br><span class="line">for product, price in zip(products, prices):</span><br><span class="line">    print(f&quot;&#123;product&#125; 的价格是 $&#123;price&#125;&quot;)</span><br><span class="line"># 输出:</span><br><span class="line"># Apple 的价格是 $1.0</span><br><span class="line"># Banana 的价格是 $0.5</span><br><span class="line"># Orange 的价格是 $1.2</span><br></pre></td></tr></table></figure>

<p>我们知道 <code>zip(products, prices)</code> 的返回值是一个 <code>zip</code> <strong>迭代器</strong>。这个迭代器在被创建时，它并不会立即生成所有配对的元组，而是<strong>按需生成</strong>。</p>
<p><strong><code>zip(products, prices)</code> 的执行：</strong></p>
<ul>
<li>当 <code>for</code> 循环开始时，它首先调用 <code>zip(products, prices)</code>。</li>
<li><code>zip()</code> 函数会创建一个 <code>zip</code> 对象（这是一个迭代器）。这个 <code>zip</code> 对象内部知道它需要从 <code>products</code> 列表和 <code>prices</code> 列表中分别取元素。</li>
<li><strong>此刻，还没有任何元组被实际创建！</strong></li>
</ul>
<p><strong>循环的第一次迭代：</strong></p>
<ul>
<li><code>for</code> 循环会要求 <code>zip</code> 迭代器给出<strong>第一个</strong>元素。</li>
<li><code>zip</code> 迭代器会从 <code>products</code> 中取出第一个元素 <code>&#39;Apple&#39;</code>，从 <code>prices</code> 中取出第一个元素 <code>1.0</code>。</li>
<li>它将这两个元素打包成一个元组：<code>(&#39;Apple&#39;, 1.0)</code>。</li>
<li>然后，这个元组 <code>(&#39;Apple&#39;, 1.0)</code> 被返回给 <code>for</code> 循环。</li>
</ul>
<p><strong>元组解包 (Tuple Unpacking)：</strong></p>
<ul>
<li>紧接着，<code>for product, price in ...</code> 这里的 <code>product, price</code> 发生了<strong>元组解包</strong>。</li>
<li>Python 将 <code>(&#39;Apple&#39;, 1.0)</code> 这个元组解包，把 <code>&#39;Apple&#39;</code> 赋值给变量 <code>product</code>，把 <code>1.0</code> 赋值给变量 <code>price</code>。</li>
<li>现在，在循环体的第一次执行中，<code>product</code> 的值是 <code>&#39;Apple&#39;</code>，<code>price</code> 的值是 <code>1.0</code>。</li>
<li><code>print(f&quot;&#123;product&#125; 的价格是 $&#123;price&#125;&quot;)</code> 就会输出 “Apple 的价格是 $1.0”。</li>
</ul>
<p><strong>循环的第二次迭代：</strong></p>
<ul>
<li><code>for</code> 循环再次要求 <code>zip</code> 迭代器给出<strong>下一个</strong>元素。</li>
<li><code>zip</code> 迭代器会从 <code>products</code> 中取出第二个元素 <code>&#39;Banana&#39;</code>，从 <code>prices</code> 中取出第二个元素 <code>0.5</code>。</li>
<li>它将这两个元素打包成一个元组：<code>(&#39;Banana&#39;, 0.5)</code>。</li>
<li>这个元组被返回给 <code>for</code> 循环，然后被解包：<code>product</code> 变为 <code>&#39;Banana&#39;</code>，<code>price</code> 变为 <code>0.5</code>。</li>
<li>循环体执行，输出 “Banana 的价格是 $0.5”。</li>
</ul>
<p><strong>循环的第三次迭代：</strong></p>
<ul>
<li>过程同上。<code>zip</code> 返回 <code>(&#39;Orange&#39;, 1.2)</code>。</li>
<li>解包后，<code>product</code> 变为 <code>&#39;Orange&#39;</code>，<code>price</code> 变为 <code>1.2</code>。</li>
<li>循环体执行，输出 “Orange 的价格是 $1.2”。</li>
</ul>
<p><strong>循环结束：</strong></p>
<ul>
<li><code>for</code> 循环再次要求 <code>zip</code> 迭代器给出<strong>下一个</strong>元素。</li>
<li>此时，<code>products</code> 和 <code>prices</code> 都已经没有更多元素了。</li>
<li><code>zip</code> 迭代器内部判断无法再生成新的配对元组，于是它会抛出 <code>StopIteration</code> 异常。</li>
<li><code>for</code> 循环捕获这个异常，并知道循环已经完成，于是退出。</li>
</ul>
<p>这种机制的优点是<strong>内存效率高</strong>。特别是当你的列表非常大时，<code>zip()</code> 不会一次性在内存中创建所有配对的元组，而是按需一个一个地生成，这在处理大数据集时尤为重要。</p>
<h1 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h1><p>Python 函数可以返回任何类型的数据，包括但不限于：</p>
<ul>
<li><p><strong>单一值：</strong> 最常见的情况，比如一个整数、一个字符串、一个布尔值、一个浮点数等。</p>
</li>
<li><p><strong>元组 (Tuple)：</strong> 当你需要返回多个独立的值时，元组是一种非常常见且推荐的方式。</p>
</li>
<li><p><strong>列表 (List)：</strong> 如果返回的是一个可变的序列，列表会更合适。</p>
</li>
<li><p><strong>字典 (Dictionary)：</strong> 当你需要返回一组键值对数据时。</p>
</li>
<li><p><strong>集合 (Set)：</strong> 如果返回的是一个无序不重复的元素集合。</p>
</li>
<li><p><strong>None：</strong> 如果函数没有明确的 <code>return</code> 语句，或者 <code>return</code> 后面没有任何值，函数会隐式地返回 <code>None</code>。</p>
</li>
<li><p><strong>自定义对象：</strong> 可以返回你自己定义的类的实例对象。</p>
</li>
<li><p><strong>其他函数：</strong> Python 函数甚至可以返回另一个函数（高阶函数）。</p>
</li>
</ul>
<p>Python 在返回<strong>多个值</strong>时，实际上会默认将这些值封装成一个<strong>元组</strong>。在这个例子中，虽然写的是 <code>return name, age, city</code>，看起来像是返回了三个独立的值，但 Python 内部会将它们自动打包成一个元组 <code>(&#39;张三&#39;, 30, &#39;北京&#39;)</code>。当用一个变量 <code>info</code> 来接收时，<code>info</code> 就成了一个元组。这种行为在 Python 中被称为**元组打包 (Tuple Packing)**。</p>
<p>如果只返回一个值，它就是那个值本身的类型：如<code>return &quot;李四&quot;</code>，<code>return a + b</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def get_user_info():</span><br><span class="line">    name = &quot;张三&quot;</span><br><span class="line">    age = 30</span><br><span class="line">    city = &quot;北京&quot;</span><br><span class="line">    return name, age, city # 看起来返回了三个值</span><br><span class="line"></span><br><span class="line"># 调用函数并接收返回值</span><br><span class="line">info = get_user_info()</span><br><span class="line">print(info)</span><br><span class="line">print(type(info))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">(&#x27;张三&#x27;, 30, &#x27;北京&#x27;)</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p><strong>面向对象编程</strong>：把一组数据和处理数据的方法组成<strong>对象</strong>，把行为相同的对象归纳为<strong>类</strong>，通过<strong>封装</strong>隐藏对象的内部细节，通过<strong>继承</strong>实现类的特化和泛化，通过<strong>多态</strong>实现基于对象类型的动态分派。</p>
<p>在面向对象编程的世界中，<strong>一切皆为对象</strong>，<strong>对象都有属性和行为</strong>，<strong>每个对象都是独一无二的</strong>，而且<strong>对象一定属于某个类</strong>。对象的属性是对象的静态特征，对象的行为是对象的动态特征。按照上面的说法，如果把拥有共同特征的对象的属性和行为都抽取出来，就可以定义出一个类。</p>
<p>在很多场景下，面向对象编程其实就是一个三步走的问题。第一步定义类，第二步创建对象，第三步给对象发消息。有的时候是不需要第一步的，因为我们想用的类可能已经存在了，找到导入并调用就行。Python内置的<code>list</code>、<code>set</code>、<code>dict</code>其实都是类，但是创建列表、集合、字典对象时，无需自定义类。当然，有的类并不是 Python 标准库中直接提供的，它可能来自于第三方的代码，在某些特殊的场景中，可能会用到名为“内置对象”的对象，所谓“内置对象”就是说上面三步走的第一步(定义类)和第二步(创建对象)都不需要了，因为类已经存在而且对象已然创建过了，直接向对象发消息就可以了，这也就是常说的“开箱即用”。</p>
<p>写在类里面的函数通常称之为<strong>方法</strong>，方法就是对象的行为，也就是对象可以接收的消息。方法的第一个参数通常都是<code>self</code>，它代表了接收这个消息的对象本身。在Python中，类的实例化对象调用方法有两种方式。第一种方法可以帮助理解<code>self</code>的含义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 通过“类.方法”调用方法</span><br><span class="line"># 第一个参数是接收消息的对象</span><br><span class="line"># 第二个参数是学习的课程名称</span><br><span class="line">Student.study(stu1, &#x27;Python程序设计&#x27;)    # 学生正在学习Python程序设计.</span><br><span class="line"># 通过“对象.方法”调用方法</span><br><span class="line"># 点前面的对象就是接收消息的对象</span><br><span class="line"># 只需要传入第二个参数课程名称</span><br><span class="line">stu1.study(&#x27;Python程序设计&#x27;)             # 学生正在学习Python程序设计.</span><br><span class="line"></span><br><span class="line">Student.play(stu2)                      # 学生正在玩游戏.</span><br><span class="line">stu2.play()                             # 学生正在玩游戏. </span><br></pre></td></tr></table></figure>

<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><blockquote>
<p>enumerate()</p>
</blockquote>
<p><code>enumerate()</code> 是 Python 中的一个内置函数，允许你在遍历序列（如列表、元组、字符串等）的同时，轻松地获取每个元素的<strong>索引</strong>及其<strong>值</strong>。这在很多场景下都比单独维护一个计数器要更加简洁。</p>
<ul>
<li><code>enumerate()</code> 用法：接受一个可迭代对象作为参数，并返回一个可迭代的 <code>enumerate</code> 对象。这个 <code>enumerate</code> 对象在每次迭代时会产生一个包含两个元素的元组：<code>(index, value)</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">enumerate(iterable, start=0)</span><br><span class="line">iterable: 必需参数，任何支持迭代的对象（例如列表、元组、字符串、字典、集合）。</span><br><span class="line">start: 可选参数，指定索引的起始值，默认为 0，并不是指可迭代对象的下标，而是开始计数的值！！</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"># 使用示例</span><br><span class="line"># 1. 遍历列表并获取索引和值</span><br><span class="line">fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]</span><br><span class="line">for index, fruit in enumerate(fruits):</span><br><span class="line">    print(f&quot;Index: &#123;index&#125;, Fruit: &#123;fruit&#125;&quot;)</span><br><span class="line">输出：</span><br><span class="line">Index: 0, Fruit: apple</span><br><span class="line">Index: 1, Fruit: banana</span><br><span class="line">Index: 2, Fruit: cherry</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 2. 从指定索引开始计数</span><br><span class="line">colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">for i, color in enumerate(colors, start=5):</span><br><span class="line">    print(f&quot;Number: &#123;i&#125;, Color: &#123;color&#125;&quot;)</span><br><span class="line">输出：</span><br><span class="line">Number: 5, Color: red</span><br><span class="line">Number: 6, Color: green</span><br><span class="line">Number: 7, Color: blue</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 3. 遍历字符串</span><br><span class="line">word = &quot;Python&quot;</span><br><span class="line">for idx, char in enumerate(word):</span><br><span class="line">    print(f&quot;Position: &#123;idx&#125;, Character: &#123;char&#125;&quot;)</span><br><span class="line">输出：</span><br><span class="line">Position: 0, Character: P</span><br><span class="line">Position: 1, Character: y</span><br><span class="line">Position: 2, Character: t</span><br><span class="line">Position: 3, Character: h</span><br><span class="line">Position: 4, Character: o</span><br><span class="line">Position: 5, Character: n</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 4. 在字典中使用 (通常是遍历键，然后通过键获取值)</span><br><span class="line"># 虽然可以直接遍历字典的键值对，但如果需要在遍历键时额外获取索引，enumerate 也很方便</span><br><span class="line">my_dict = &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3&#125;</span><br><span class="line">for i, key in enumerate(my_dict):</span><br><span class="line">    print(f&quot;Index: &#123;i&#125;, Key: &#123;key&#125;, Value: &#123;my_dict[key]&#125;&quot;)</span><br><span class="line">输出：</span><br><span class="line">Index: 0, Key: a, Value: 1</span><br><span class="line">Index: 1, Key: b, 雅安: 2</span><br><span class="line">Index: 2, Key: c, Value: 3</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 5. 使用 enumerate() 的结果直接转换为列表或元组</span><br><span class="line">fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]</span><br><span class="line">colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">enumerated_list = list(enumerate(fruits))</span><br><span class="line">print(f&quot;List from enumerate: &#123;enumerated_list&#125;&quot;)</span><br><span class="line"></span><br><span class="line">enumerated_tuple = tuple(enumerate(colors, start=10))</span><br><span class="line">print(f&quot;Tuple from enumerate: &#123;enumerated_tuple&#125;&quot;)</span><br><span class="line">输出：</span><br><span class="line">List from enumerate: [(0, &#x27;apple&#x27;), (1, &#x27;banana&#x27;), (2, &#x27;cherry&#x27;)]</span><br><span class="line">Tuple from enumerate: ((10, &#x27;red&#x27;), (11, &#x27;green&#x27;), (12, &#x27;blue&#x27;))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sort()               # 与高阶函数sorted()不同</p>
</blockquote>
<p><code>sort()</code> 是 Python 中<strong>列表对象的一个方法</strong>，它的主要功能是<strong>对列表中的元素进行原地排序</strong>。这意味着它会直接修改原始列表，而不是创建一个新的已排序列表。</p>
<ul>
<li><strong>原地排序 (In-place Sorting):</strong> 这是 <code>sort()</code> 最重要的特性。<strong>它不会返回一个新的排序后的列表，而是直接修改调用它的列表</strong>。因此，如果需要保留原始列表的顺序，应该先复制一份列表再进行排序，或者使用 <code>sorted()</code>函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_list = [3, 1, 4, 1, 5, 9, 2]</span><br><span class="line">my_list.sort() # 直接修改 my_list</span><br><span class="line">print(my_list) # 输出: [1, 1, 2, 3, 4, 5, 9]</span><br><span class="line"></span><br><span class="line">original_list = [5, 2, 8]</span><br><span class="line">sorted_list = original_list.copy() # 先复制一份</span><br><span class="line">sorted_list.sort()</span><br><span class="line">print(original_list) # 输出: [5, 2, 8] (原始列表未变)</span><br><span class="line">print(sorted_list)   # 输出: [2, 5, 8]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>默认升序排序:</strong> 如果没有指定其他参数，<code>sort()</code> 默认会按照元素的自然顺序进行升序排列。</p>
<ul>
<li><p>数字：从小到大</p>
</li>
<li><p>字符串：按字母顺序（ASCII 值）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">numbers = [5, 2, 8, 1, 9]</span><br><span class="line">numbers.sort()</span><br><span class="line">print(numbers) # 输出: [1, 2, 5, 8, 9]</span><br><span class="line"></span><br><span class="line">words = [&quot;banana&quot;, &quot;apple&quot;, &quot;cherry&quot;]</span><br><span class="line">words.sort()</span><br><span class="line">print(words) # 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span><br><span class="line"></span><br><span class="line"># 可以通过设置 reverse=True 参数来实现降序排序。</span><br><span class="line">data = [10, 4, 7, 1, 9]</span><br><span class="line">data.sort(reverse=True)</span><br><span class="line">print(data) # 输出: [10, 9, 7, 4, 1]</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义排序 (<code>key</code> 参数)<ul>
<li><code>sort()</code> 方法提供了一个 <code>key</code> 参数，允许指定一个函数，该函数会在比较元素之前对每个元素进行处理。<code>key</code> 函数会接收列表中的每个元素作为参数，并返回一个用于比较的值。这在排序复杂对象（如包含字典、自定义对象或元组的列表）时非常有用。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 按照字符串长度排序</span><br><span class="line">words = [&quot;banana&quot;, &quot;apple&quot;, &quot;cherry&quot;, &quot;kiwi&quot;]</span><br><span class="line">words.sort(key=len)</span><br><span class="line">print(words) # 输出: [&#x27;kiwi&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span><br><span class="line"></span><br><span class="line"># 按照字典中 &#x27;age&#x27; 键的值排序</span><br><span class="line">people = [</span><br><span class="line">    &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30&#125;,</span><br><span class="line">    &#123;&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 25&#125;,</span><br><span class="line">    &#123;&quot;name&quot;: &quot;Charlie&quot;, &quot;age&quot;: 35&#125;</span><br><span class="line">]</span><br><span class="line">people.sort(key=lambda person: person[&quot;age&quot;])</span><br><span class="line">print(people)</span><br><span class="line"># 输出: [&#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 25&#125;, &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30&#125;, &#123;&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;age&#x27;: 35&#125;]</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Python语法</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://liuhengfeng.xyz/posts/3152c1c3.html">https://liuhengfeng.xyz/posts/3152c1c3.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>LHF</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-03-20</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-03-20</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/">技能学习</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://statics.liuhengfeng.xyz/Hexo/PixPin_2025-03-19_13-48-56.png" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/9e5736b2.html" title="Python的异步编程:asyncio"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/PixPin_2025-03-20_16-28-03.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python的异步编程:asyncio</div></div></a></div><div class="next-post pull-right"><a href="/posts/29dc6fe8.html" title="Docker常用命令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/PixPin_2025-03-17_16-01-30.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker常用命令</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/9e5736b2.html" title="Python的异步编程:asyncio"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/PixPin_2025-03-20_16-28-03.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-20</div><div class="title">Python的异步编程:asyncio</div></div></a></div><div><a href="/posts/2ca90abc.html" title="AI基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/bc18e18a-2e2d-4378-9c15-f1c678fc5ed1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-19</div><div class="title">AI基础知识</div></div></a></div><div><a href="/posts/e61f9869.html" title="DeepSeek模型原理与应用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/PixPin_2025-05-15_14-07-51.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-15</div><div class="title">DeepSeek模型原理与应用</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E5%8C%85-import"><span class="toc-number">1.</span> <span class="toc-text">导包(import)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.</span> <span class="toc-text">包与模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E5%AF%BC%E5%8C%85%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.</span> <span class="toc-text">Python导包相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#init-py%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">__init__.py的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%8C%85%E8%A7%84%E5%88%99"><span class="toc-number">1.2.2.</span> <span class="toc-text">导包规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E6%96%B0%E7%9A%84%E5%AF%BC%E5%8C%85%E8%B7%AF%E5%BE%84%EF%BC%88%E7%A8%B3%E5%AE%9A%E8%A7%A3%E5%86%B3ModuleNotFoundError%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">追加新的导包路径（稳定解决ModuleNotFoundError）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">2.</span> <span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E7%9A%84%E9%94%AE"><span class="toc-number">2.1.</span> <span class="toc-text">字典的键</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">位置参数与关键字参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%EF%BC%88Positional-Argument%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. 位置参数（Positional Argument）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%EF%BC%88Keyword-Argument%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2. 关键字参数（Keyword Argument）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3. 混合使用位置参数和关键字参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%EF%BC%88Default-Argument%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">4. 默认参数（Default Argument）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84-%E7%AC%A6%E5%8F%B7%E5%90%AB%E4%B9%89"><span class="toc-number">3.5.</span> <span class="toc-text">5.函数参数列表中的*符号含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%94%B6%E9%9B%86%E5%99%A8-%E5%8F%82%E6%95%B0%E8%A7%A3%E5%8C%85%E5%99%A8-args%E3%80%81kwargs%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">参数收集器&#x2F;参数解包器(args、kwargs）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#args"><span class="toc-number">4.1.</span> <span class="toc-text">*args</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kwargs"><span class="toc-number">4.2.</span> <span class="toc-text">**kwargs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">Python装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">带参数的装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">类装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">带参数的类装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.4.</span> <span class="toc-text">装饰器的顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">框架中的装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84Python%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">经典的Python装饰器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">类方法&amp;静态方法&amp;抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">抽象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">lambda函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda-%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.1.</span> <span class="toc-text">lambda 函数常见使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python%E8%A7%A3%E5%8C%85"><span class="toc-number">8.</span> <span class="toc-text">Python解包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E5%8C%85"><span class="toc-number">8.1.</span> <span class="toc-text">封包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%A7%A3%E5%8C%85"><span class="toc-number">8.2.</span> <span class="toc-text">基础解包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%A7%A3%E5%8C%85"><span class="toc-number">8.3.</span> <span class="toc-text">扩展解包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E8%A7%A3%E5%8C%85"><span class="toc-number">8.4.</span> <span class="toc-text">字典解包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8C%85"><span class="toc-number">8.5.</span> <span class="toc-text">循环中的解包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.6.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">Python高阶函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">可迭代对象&amp;迭代器&amp;生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%BF%98%E4%B8%8D%E5%A4%9F%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.1.</span> <span class="toc-text">为什么有可迭代对象还不够，还需要迭代器?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%85%E6%9C%89%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%A4%9F%EF%BC%9F"><span class="toc-number">10.1.1.</span> <span class="toc-text">为什么仅有可迭代对象不够？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E5%92%8C-for-in-%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.1.2.</span> <span class="toc-text">迭代器 (Iterator) 和 for ... in ... 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zip-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A%E4%B8%80%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.1.3.</span> <span class="toc-text">zip() 函数的返回值：一个迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">11.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">面向对象编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">常用函数</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-wrap" id="footer-wrap"> <div class="copyright">&copy;2024 - 2025 By LHF</div><div class="footer_custom_text"><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><canvas id="universe"></canvas><script src="https://statics.liuhengfeng.xyz/js/jquery-3.6.1.min.js"></script><script async src="https://unpkg.com/vue@2.6.14/dist/vue.min.js"></script><script async src="https://unpkg.com/element-ui@2.15.6/lib/index.js"></script><script async src="https://liu-hexo.oss-cn-guangzhou.aliyuncs.com/js/lunar.min.js"></script><script src="/js/calendar.min.js"></script><script async src="https://statics.liuhengfeng.xyz/js/common.min.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false#  open shake (抖動特效);
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('card-widget card-announcement')[2];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'f89c5a6b949a4345a0d22f0ad5b040ea';
  var gaud_map_key = 'a36227a8c2b6dcd6b90a98920a06ac89';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '108.230574,22.793414';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://devapi.qweather.com/v7/weather/now?key=f89c5a6b949a4345a0d22f0ad5b040ea"></script><script data-pjax src="https://liu-hexo.oss-cn-guangzhou.aliyuncs.com/js/electric_clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="博客主题为Butterfly" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-d021d6?style=flat&amp;logo=buefy&amp;color=purple" alt=""/></a><a class="github-badge" target="_blank" href="https://pages.github.com/" style="margin-inline:5px" data-title="本站项目托管于Github Pages" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github%20Pages-d021d6?style=flat&amp;logo=githubpages&amp;color=brown" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="GitHub万岁" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Thanks-Github-d021d6?style=flat&amp;logo=GitHub&amp;color=indigo" alt=""/></a><a class="github-badge" target="_blank" href="https://www.alibabacloud.com/zh/product/content-delivery-network?_p_lc=1" style="margin-inline:5px" data-title="网站资源使用阿里云CDN加速" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-%E9%98%BF%E9%87%8C%E4%BA%91CDN-d021d6?style=flat&amp;logo=speedtest&amp;color=blue" alt=""/></a><a class="github-badge" target="_blank" href="https://www.aliyun.com/benefit" style="margin-inline:5px" data-title="本站图床部署于阿里云OSS" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/OSS-%E9%98%BF%E9%87%8C%E4%BA%91OSS-d021d6?style=flat&amp;logo=alibabacloud&amp;color=orange" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn" style="margin-inline:5px" data-title="网站备案号" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/ICP-%E6%A1%82ICP%E5%A4%872023012461%E5%8F%B7-d021d6?style=flat&amp;logo=brandfolder&amp;color=yellow" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=creativecommons" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4433d2d6.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/day_news.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-06</span><a class="blog-slider__title" href="posts/4433d2d6.html" alt="">每天60秒读懂世界</a><div class="blog-slider__text">每日新闻早报</div><a class="blog-slider__button" href="posts/4433d2d6.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/c47516f6.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/PixPin_2025-05-10_16-40-48.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-05-10</span><a class="blog-slider__title" href="posts/c47516f6.html" alt="">Note_of_Learning(CS&amp;AI)</a><div class="blog-slider__text">一些笔记杂记，主要是AI方面的</div><a class="blog-slider__button" href="posts/c47516f6.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/e4ce9af4.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/4de89523-2218-4748-8b18-5b961e39906d.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-06</span><a class="blog-slider__title" href="posts/e4ce9af4.html" alt="">2025</a><div class="blog-slider__text">My Life in 2025!</div><a class="blog-slider__button" href="posts/e4ce9af4.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/93c9aa62.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://statics.liuhengfeng.xyz/Hexo/20241105bg2.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-05</span><a class="blog-slider__title" href="posts/93c9aa62.html" alt="">2024</a><div class="blog-slider__text">My Life In 2024!</div><a class="blog-slider__button" href="posts/93c9aa62.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://statics.liuhengfeng.xyz/js/swiper.min.js"></script><script defer data-pjax src="https://statics.liuhengfeng.xyz/js/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInRight');
    arr[i].setAttribute('data-wow-duration', '500ms');
    arr[i].setAttribute('data-wow-delay', '300ms');
    arr[i].setAttribute('data-wow-offset', '180');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInLeft');
    arr[i].setAttribute('data-wow-duration', '500ms');
    arr[i].setAttribute('data-wow-delay', '300ms');
    arr[i].setAttribute('data-wow-offset', '180');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('footer-wrap');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__backInUp');
    arr[i].setAttribute('data-wow-duration', '500ms');
    arr[i].setAttribute('data-wow-delay', '300ms');
    arr[i].setAttribute('data-wow-offset', '180');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('show');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInDown');
    arr[i].setAttribute('data-wow-duration', '500ms');
    arr[i].setAttribute('data-wow-delay', '300ms');
    arr[i].setAttribute('data-wow-offset', '180');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('is-center');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInLeft');
    arr[i].setAttribute('data-wow-duration', '500ms');
    arr[i].setAttribute('data-wow-delay', '300ms');
    arr[i].setAttribute('data-wow-offset', '180');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-info-data');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInLeft');
    arr[i].setAttribute('data-wow-duration', '500ms');
    arr[i].setAttribute('data-wow-delay', '300ms');
    arr[i].setAttribute('data-wow-offset', '180');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-info-social-icons');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInLeft');
    arr[i].setAttribute('data-wow-duration', '500ms');
    arr[i].setAttribute('data-wow-delay', '300ms');
    arr[i].setAttribute('data-wow-offset', '180');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-info-btn');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInLeft');
    arr[i].setAttribute('data-wow-duration', '500ms');
    arr[i].setAttribute('data-wow-delay', '300ms');
    arr[i].setAttribute('data-wow-offset', '180');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>